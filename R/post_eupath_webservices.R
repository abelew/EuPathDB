## This file should include any functions which perform a POST operation to one
## of the eupathdb web servers.

#' Gather all available annotation data for a given eupathdb species.
#'
#' This function fills in the parameters to post_eupath_raw() so that one can
#' download all the available data for a given parasite into one massive table.
#' It should also provide some constraints to the data rather than leaving it
#' all as characters.  Caveat:  I manually filled in the list 'field_list' to
#' include the variable names and their text associations.  This is likely to
#' change in future releases of the tritrypdb.  It is probably possible to
#' automagically fill it in.  In addition, I am using GenesByMolecularWeight to
#' get the data, which is a bit weird.
#'
#' @param entry  The full annotation entry.
#' @param dir  FIXME: I want to write some intermediate data to dir in case of
#'   transient error.
#' @return  A big honking table.
post_eupath_annotations <- function(entry=NULL, dir="eupathdb", overwrite=FALSE) {
  if (is.null(entry)) {
    stop("Need an entry from the eupathdb.")
  }
  species <- entry[["Species"]]
  savefile <- file.path(dir, glue::glue("{entry[['Genome']]}_annotations.rda"))
  if (file.exists(savefile)) {
    if (isTRUE(overwrite)) {
      removed <- file.remove(savefile)
    } else {
      message("We can save some time by reading the savefile.")
      message("Delete the file ", savefile, " to regenerate.")
      result <- new.env()
      load(savefile, envir=result)
      result <- result[["result"]]
      return(result)
    }
  }

  ## query body as a structured list
  ## This list was generated by going to:
  ## view-source:http://tritrypdb.org/webservices/GeneQuestions/GenesByMolecularWeight.wadl
  ## scrolling down to the 'o-fields' section, and writing down the most likely
  ## useful column names. These are written one per line in an attempt to make
  ## looking for new/changed columns from one eupathdb release to the next
  ## easier.

  parameters <- list(
    "organism" = jsonlite::unbox(species),
    "min_molecular_weight" = jsonlite::unbox("1"),
    "max_molecular_weight" = jsonlite::unbox("10000000000000000")
  )
  question <- "GeneQuestions.GenesByMolecularWeight"
  table_name <- "annot"
  result <- post_eupath_raw(entry, question=question,
                            parameters=parameters, table_name=table_name)
  colnames(result) <- tolower(colnames(result))
  numeric_columns <- c(
    "annot_gene_exon_count",
    "annot_gene_transcript_count",
    "annot_gene_ortholog_number",
    "annot_gene_paralog_number",
    "annot_gene_total_hts_snps",
    "annot_gene_hts_nonsynonymous_snps",
    "annot_gene_hts_synonymous_snps",
    "annot_gene_hts_noncoding_snps",
    "annot_gene_hts_stop_codon_snps",
    "annot_gene_hts_nonsyn_syn_ratio",
    "annot_transcript_length",
    "annot_exon_count",
    "annot_cds_length",
    "annot_tm_count",
    "annot_molecular_weight",
    "annot_isoelectric_point",
    "annot_five_prime_utr_length",
    "annot_three_prime_utr_length")
  for (col in numeric_columns) {
    if (!is.null(result[[col]])) {
      result[[col]] <- as.numeric(result[[col]])
    }
  }
  factor_columns <- c(
    "annot_chromosome",
    "annot_gene_type",
    "annot_is_pseudo",
    "annot_strand",
    "annot_tm_count",
    "annot_exon_count")
  for (col in factor_columns) {
    if (!is.null(result[[col]])) {
      result[[col]] <- as.factor(result[[col]])
    }
  }
  colnames(result) <- toupper(colnames(result))

  message("Saving annotations to ", savefile)
  save(result, file=savefile)
  return(result)
}

#' The new eupath system provides 3 output types for downloading data.  This
#' uses the raw one.
#'
#' For the life of me, I could not figure out how to query the big text tables
#' as the tabular format.  Every query I sent came back telling me I gave it
#' incorrect parameter despite the fact that I was copy/pasting the example
#' given me by the eupathdb maintainers. So, I got mad and asked it for the raw
#' format, and so this function was born.
#'
#' @param entry  Annotation entry for a given species
#' @param question  Which query to try?  Molecular weight is the easiest, as it
#'   was their example.
#' @param parameters  Query parameters when posting
#' @param table_name  Used to make sure all columns are unique by prefixing them
#'   with the table name.
#' @param columns  Columns for which to ask.
#' @param minutes  How long to wait until giving up and throwing an error.
#' @return  A hopefully huge table of eupath data.
post_eupath_raw <- function(entry, question="GeneQuestions.GenesByMolecularWeight",
                            parameters=NULL, table_name=NULL, columns=NULL,
                            minutes=10) {
  species <- entry[["Species"]]
  provider <- tolower(entry[["DataProvider"]])
  ## determine appropriate prefix to use
  uri_prefix <- prefix_map(provider)
  if (is.null(parameters)) {
    parameters <- list("organism" = jsonlite::unbox(species))
  }

  query_columns <- columns
  if (is.null(columns)) {
    query_columns <- get_eupath_fields(provider)
  }

  answerlist <- list(
    "questionName" = jsonlite::unbox(question),
    "parameters" = parameters,
    "viewFilters" = list(),
    "filters" = list())
  formattinglist <- list(
    "formatConfig" = list(
      "includeHeaders" = jsonlite::unbox("true"),
      "attributes" = query_columns,
      "attachmentType" = jsonlite::unbox("plain")),
    "format" = jsonlite::unbox("fullRecord"))
  query_body <- list(
    "answerSpec" = answerlist,
    "formatting" = formattinglist)

  body <- jsonlite::toJSON(query_body)
  api_uri <- glue::glue("https://{provider}.org/{uri_prefix}/service/answer/report")
  result <- httr::POST(url=api_uri, body=body,
                       httr::content_type("application/json"),
                       httr::timeout(minutes * 60))
  if (result[["status_code"]] == "422") {
    warning("The provided species does not have a table of weights.")
    return(data.frame())
  } else if (result[["status_code"]] == "400") {
    warning("Status 400 was returned, likely a bad formatConfig.")
  } else if (result[["status_code"]] == "404") {
    warning("A 404 was returned, check the url: ", api_url)
  } else if (result[["status_code"]] != "200") {
    warning("An error status code was returned.")
    return(data.frame())
  } else if (length(result[["content"]]) < 100) {
    warning("A minimal amount of content was returned.")
  }

  ## Get the content, this will take a while, as the result from eupathdb might
  ## be > 50 Mb of stuff.
  cont <- httr::content(result, encoding="UTF-8")
  ## Sadly, most of that stuff is completely unwanted.  This is because we are
  ## using the 'fullRecord' format, as it is the only format I have been able to
  ## get to work so far. This format is newline separated fields with entries
  ## separated by 4 returns with dashes... Ergo the following line, which
  ## separates the entries by the dashes/returns into individual strings with
  ## the newlines remaining inside them.  So we will need to use some regular
  ## expressions in order to extract the column names and data.
  entries <- strsplit(
    x=cont, split="\n\n------------------------------------------------------------\n\n")[[1]]
  ## We will read the first entry in order to extract the column names.
  entry <- read.delim(textConnection(entries[1]), sep="\n", header=FALSE)
  entry[["V1"]] <- as.character(entry[["V1"]])
  ## My regular expression pattern needs to by greedy in the correct places
  ## because for reasons passing all understanding, some fields have colons inside them...
  mypattern <- "^(.+?\\:) (.+)?$"
  ## If I am going to make column names, I need first to get the first part of
  ## stuff: otherstuff
  regex_column_names <- gsub(pattern=mypattern, replacement="\\1",
                             x=entry[["V1"]], perl=TRUE)
  ## At least one column is completely nutty, in that it includes return characters inside its data.
  ## 'Cellular localization images:' contains <span>stuff\nstuff\nstuff</span>
  ## which of course causes my read.delim above to think it is three separate columns.
  ## Therefore I will remove it here.
  good_column_idx <- grepl(x=regex_column_names, pattern=":$")
  regex_column_names <- regex_column_names[good_column_idx]
  ## Get rid of the colons
  regex_column_names <- gsub(pattern=":", replacement="", x=regex_column_names)
  ## spaces
  regex_column_names <- gsub(pattern="\\s+", replacement="_", x=regex_column_names)
  ## number signs '#'
  regex_column_names <- gsub(pattern="#", replacement="num", x=regex_column_names)
  ## dashes
  regex_column_names <- gsub(pattern="-", replacement="_", x=regex_column_names)
  ## slashes
  regex_column_names <- gsub(pattern="/", replacement="", x=regex_column_names)
  ## parens
  regex_column_names <- gsub(pattern="\\(|\\)", replacement="", x=regex_column_names)
  ## and single-quotes
  regex_column_names <- gsub(pattern="'", replacement="p", x=regex_column_names)

  if (length(query_columns) == length(regex_column_names)) {
    column_names <- query_columns
  } else {
    column_names <- make.names(regex_column_names, unique=TRUE)
  }

  ## Create an empty data frame into which we will dump the text.
  column_names[1] <- "GID"
  information <- data.frame(row.names=1:length(entries))
  for (col in column_names) {
    new_col <- rep(NA, times=length(entries))
    information <- cbind(information, new_col)
  }
  colnames(information) <- column_names

  show_progress <- interactive() && is.null(getOption("knitr.in.progress"))
  if (isTRUE(show_progress)) {
    bar <- utils::txtProgressBar(style=3)
  }
  ## Now fill in the data using the other side of my regular expression.
  for (c in 1:length(entries)) {
    if (isTRUE(show_progress)) {
      pct_done <- c / length(entries)
      setTxtProgressBar(bar, pct_done)
    }
    entry <- read.delim(textConnection(entries[c]), sep="\n", header=FALSE)
    entry[["V1"]] <- as.character(entry[["V1"]])
    material <- gsub(pattern=mypattern, replacement="\\2", x=entry[["V1"]])
    information[c, ] <- material
  }
  if (isTRUE(show_progress)) {
    close(bar)
  }
  ## remove duplicated rows
  information <- information[!duplicated(information), ]
  ## In some cases we will want to prefix the columns with the table name...
  if (!is.null(table_name)) {
    for (c in 2:length(colnames(information))) {
      col_name <- colnames(information)[c]
      prefix_string <- glue::glue("{toupper(table_name)}_")
      ## Use if() test this to avoid column names like 'GO_GO_ID'
      foundp <- grepl(pattern=glue::glue("^{prefix_string}"), x=toupper(col_name))
      if (!foundp) {
        new_col <- glue::glue("{toupper(table_name)}_{toupper(col_name)}")
        colnames(information)[c] <- new_col
      }
    }
  }
  return(information)
}

#' Queries one of the EuPathDB APIs using a POST request and returns a
#' dataframe representation of the result.
#' Note: As of 2017/07/13, POST requests are not yet supported on EuPathDB.
#' Note: 2017/07/13 POST queries can only use the new API
#'
#' @param query_body String of additional query arguments
#' @param entry The single metadatum containing the base url of the provider, species, etc.
#' @param table_name  The name of the table to extract, this is provided to make
#'   for prettier labeling.
#' @param minutes  A timeout when querying the eupathdb.
#' @param ...  Extra arguments for stuff like download_metadtata()
#' @return list containing response from API request.
#'
#' More information
#' ----------------
#' 1. https://tritrypdb.org/tritrypdb/serviceList.jsp
#' @author Keith Hughitt
#' @export
post_eupath_table <- function(query_body, entry, table_name=NULL, minutes=10) {
  if (is.null(entry)) {
    stop("This requires a eupathdb entry.")
  }

  ## determine appropriate prefix to use
  species <- entry[["Species"]]
  provider <- tolower(entry[["DataProvider"]])
  uri_prefix <- prefix_map(provider)

  ## construct API query
  api_uri <- glue::glue("https://{provider}.org/{uri_prefix}/service/answer/report")
  body <- jsonlite::toJSON(query_body)
  result <- httr::POST(url=api_uri, body=body,
                       httr::content_type("application/json"),
                       httr::timeout(minutes * 60))
  if (result[["status_code"]] == "422") {
    warning("The provided species does not have a table of weights.")
    return(data.frame())
  } else if (result[["status_code"]] != "200") {
    warning("An error status code was returned.")
    return(data.frame())
  } else if (length(result[["content"]]) < 100) {
    warning("A minimal amount of content was returned.")
  }

  result <- httr::content(result, encoding="UTF-8")
  result <- read.delim(textConnection(result), sep="\t")
  ## If nothing was received, return nothing.
  if (nrow(result) == 0) {
    return(data.frame())
  }

  ## If a column is just 'X', then I think it can go away.
  non_stupid_columns <- colnames(result) != "X"
  result <- result[, non_stupid_columns]

  ## simplify column names, the are downloaded with
  ## annoyingly stupid names like:
  ## > colnames(dat)
  ## [1] "X.Gene.ID."                        "X.pathway_source_id."
  ## [3] "X.Pathway."                        "X.Pathway.Source."
  ## [5] "X.EC.Number.Matched.in.Pathway."   "X.expasy_url."
  ## [7] "X...Reactions.Matching.EC.Number."
  new_colnames <- toupper(colnames(result))
  ## Get rid of dumb X. prefix
  new_colnames <- gsub("^X\\.+", replacement="", x=new_colnames)
  ## Get rid of spurious end .
  new_colnames <- gsub("\\.$", replacement="", x=new_colnames)
  ## Get rid of internal .'s
  new_colnames <- gsub("\\.", replacement="_", x=new_colnames)
  colnames(result) <- new_colnames
  colnames(result)[1] <- "GID"
  ## remove duplicated rows
  result <- result[!duplicated(result), ]
  if (!is.null(table_name)) {
    for (c in 2:length(colnames(result))) {
      col_name <- colnames(result)[c]
      new_col <- glue::glue("{toupper(table_name)}_{toupper(col_name)}")
      colnames(result)[c] <- new_col
    }
  }
  return(result)
}

#'  Use the post interface to get GO data.
#'
#' @param entry  The full annotation entry.
#' @param dir  FIXME: I want to write some intermediate data to dir in case of
#'   transient error.
#' @return  A big honking table.
post_eupath_go_table <- function(entry=NULL, dir="eupathdb", overwrite=FALSE) {
  if (is.null(entry)) {
    stop("Need an entry from the eupathdb.")
  }
  species <- entry[["Species"]]
  ## query body as a structured list
  ## Parameters taken from the pdf "Exporting Data - Web Services.pdf" received
  ## from Cristina

  savefile <- file.path(dir, glue::glue("{entry[['Genome']]}_go_table.rda"))
  if (file.exists(savefile)) {
    if (isTRUE(overwrite)) {
      removed <- file.remove(savefile)
    } else {
      message("We can save some time by reading the savefile.")
      message("Delete the file ", savefile, " to regenerate.")
      result <- new.env()
      load(savefile, envir=result)
      result <- result[["result"]]
      return(result)
    }
  }

  query_body <- list(
    ## 3 elements, answerSpec, formatting, format.
    "answerSpec" = list(
      "questionName" = jsonlite::unbox("GeneQuestions.GenesByTaxonGene"),
      "parameters" = list("organism" = jsonlite::unbox(species)),
      "viewFilters" = list(),
      "filters" = list()
    ),
    "formatting" = list(
      "formatConfig" = list(
        "tables" = "GOTerms",
        "includeEmptyTables" = jsonlite::unbox("true"),
        "attachmentType" = jsonlite::unbox("plain")
      ),
      "format" = jsonlite::unbox("tableTabular")
    ))

  result <- post_eupath_table(query_body, entry, table_name="go")
  message("Saving annotations to ", savefile)
  save(result, file=savefile)
  return(result)
}

#' Use the post interface to get ortholog data.
#'
#' Unfortunately, this function more often then not leads to a crash of the
#' eupathdb webservers.  As a result, I wrote a GET version of this which
#' iterates one gene at a time.
#'
#' @param entry  The full annotation entry.
#' @param dir  FIXME: I want to write some intermediate data to dir in case of
#'   transient error.
#' @return  A big honking table.
post_eupath_ortholog_table <- function(entry=NULL, dir="eupathdb", table="OrthologsLite",
                                       overwrite=FALSE) {
  if (is.null(entry)) {
    stop("Need an entry from the eupathdb.")
  }
  species <- entry[["Species"]]
  savefile <- file.path(dir, glue::glue("{entry[['Genome']]}_ortholog_table.rda"))
  if (file.exists(savefile)) {
    if (isTRUE(overwrite)) {
      removed <- file.remove(savefile)
    } else {
      message("We can save some time by reading the savefile.")
      message("Delete the file ", savefile, " to regenerate.")
      result <- new.env()
      load(savefile, envir=result)
      result <- result[["result"]]
      return(result)
    }
  }

  ## query body as a structured list
  ## Parameters taken from the pdf "Exporting Data - Web Services.pdf" received
  ## from Cristina
  query_body <- list(
    ## 3 elements, answerSpec, formatting, format.
    "answerSpec" = list(
      "questionName" = jsonlite::unbox("GeneQuestions.GenesByTaxonGene"),
      "parameters" = list("organism" = jsonlite::unbox(species)),
      "viewFilters" = list(),
      "filters" = list(),
      "wdk_weight" = jsonlite::unbox(10)
    ),
    "formatting" = list(
      "formatConfig" = list(
        "tables" = table,
        "includeEmptyTables" = jsonlite::unbox("false"),
        "attachmentType" = jsonlite::unbox("plain")
      ),
      "format" = jsonlite::unbox("tableTabular")
    ))

  result <- post_eupath_table(query_body, entry, table_name="orthologs")
  message("Saving annotations to ", savefile)
  save(result, file=savefile)
  return(result)
}

#'  Use the post interface to get interpro data.
#'
#' @param entry  The full annotation entry.
#' @param dir  FIXME: I want to write some intermediate data to dir in case of
#'   transient error.
#' @return  A big honking table.
post_eupath_interpro_table <- function(entry=NULL, dir="eupathdb", overwrite=FALSE) {
  if (is.null(entry)) {
    stop("Need an entry from the eupathdb.")
  }
  savefile <- file.path(dir, glue::glue("{entry[['Genome']]}_interpro_table.rda"))
  if (file.exists(savefile)) {
    if (isTRUE(overwrite)) {
      removed <- file.remove(savefile)
    } else {
      message("We can save some time by reading the savefile.")
      message("Delete the file ", savefile, " to regenerate.")
      result <- new.env()
      load(savefile, envir=result)
      result <- result[["result"]]
      return(result)
    }
  }

  species <- entry[["Species"]]
  ## query body as a structured list
  ## Parameters taken from the pdf "Exporting Data - Web Services.pdf" received
  ## from Cristina
  query_body <- list(
    ## 3 elements, answerSpec, formatting, format.
    "answerSpec" = list(
      "questionName" = jsonlite::unbox("GeneQuestions.GenesByTaxonGene"),
      "parameters" = list("organism" = jsonlite::unbox(species)),
      "viewFilters" = list(),
      "filters" = list()
    ),
    "formatting" = list(
      "formatConfig" = list(
        "tables" = "InterPro",
        "includeEmptyTables" = jsonlite::unbox("true"),
        "attachmentType" = jsonlite::unbox("plain")
      ),
      "format" = jsonlite::unbox("tableTabular")
    ))

  result <- post_eupath_table(query_body, entry, table_name="interpro")
  message("Saving annotations to ", savefile)
  save(result, file=savefile)
  return(result)
}

#'  Use the post interface to get pathway data.
#'
#' @param entry  The full annotation entry.
#' @param dir  FIXME: I want to write some intermediate data to dir in case of
#'   transient error.
#' @return  A big honking table.
post_eupath_pathway_table <- function(entry=NULL, dir="eupathdb", overwrite=FALSE) {
  if (is.null(entry)) {
    stop("Need a eupathdb entry.")
  }
  species <- entry[["Species"]]
  savefile <- file.path(dir, glue::glue("{entry[['Genome']]}_pathway_table.rda"))
  if (file.exists(savefile)) {
    if (isTRUE(overwrite)) {
      removed <- file.remove(savefile)
    } else {
      message("We can save some time by reading the savefile.")
      message("Delete the file ", savefile, " to regenerate.")
      result <- new.env()
      load(savefile, envir=result)
      result <- result[["result"]]
      return(result)
    }
  }

  ## query body as a structured list
  ## Parameters taken from the pdf "Exporting Data - Web Services.pdf" received
  ## from Cristina
  query_body <- list(
    ## 2 elements, answerSpec, formatting.
    "answerSpec" = list(
      "questionName" = jsonlite::unbox("GeneQuestions.GenesByTaxonGene"),
      "parameters" = list("organism" = jsonlite::unbox(species)),
      "viewFilters" = list(),
      "filters" = list()
    ),
    "formatting" = list(
      "formatConfig" = list(
        "tables" = "MetabolicPathways",
        "includeEmptyTables" = jsonlite::unbox("false"),
        "attachmentType" = jsonlite::unbox("plain")
      ),
      "format" = jsonlite::unbox("tableTabular")
    ))

  result <- post_eupath_table(query_body, entry, table_name="pathway")
  message("Saving annotations to ", savefile)
  save(result, file=savefile)
  return(result)
}
