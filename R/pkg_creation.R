#' Cleans up illegal characters in packages generated by make_organismdbi(),
#' make_orgdb(), and make_txdb(). This attempts to fix some of the common
#' problems therein.
#'
#' The primary problem this function seeks to solve is derived from the fact
#' that some species names in the eupathdb contain characters which are not
#' allowed in orgdb/txdb/organismdbi instances.  Thus this invokes a couple of
#' regular expressions in an attempt to make sure these generated packages are
#' actually installable.
#'
#' One thing I should consider is to add some of this logic to my eupath queries
#' rather than perform these clunky modifications to the already-generated
#' packages.
#'
#' @param path  Location for the original Db/Dbi instance.
#' @param removal  String to remove from the instance.
#' @param replace  What to replace removal with, when necessary.
#' @param sqlite  Also modify the sqlite database?
#' @return  A hopefully cleaner OrgDb/TxDb/OrganismDbi sqlite package.
#' @author atb
#' @export
clean_pkg <- function(path, removal="-like", replace="", sqlite=TRUE) {
  ## This is because TxDb creation fails if you have an author like 'abelew <abelew@gmail.com>'
  ##at_cmd <- paste0("sed -i 's/ at /\\@/g' ", path, "/DESCRIPTION")
  basedir <- dirname(path)
  dir <- basename(path)
  full_path <- file.path(basedir, dir)
  ## at_cmd <- paste0("perl -p -i -e 's/ at /\\@/g' ", full_path, "/DESCRIPTION")
  at_cmd <- glue::glue("perl -p -i -e 's/ at /\\@/g' {full_path}/DESCRIPTION")
  system(command=at_cmd)
  ## Since I changed @ to at I figured . could be dot too
  ## dot_cmd <- paste0("perl -p -i -e 's/ dot /\\./g' ", full_path, "/DESCRIPTION")
  dot_cmd <- glue::glue("perl -p -i -e 's/ dot /\\./g' {full_path}/DESCRIPTION")
  system(dot_cmd)

  new_dir <- dir
  new_path <- file.path(basedir, new_dir)
  if (grepl(pattern=removal, x=dir)) {
    ## Get rid of the -like in the path name
    new_dir <- gsub(pattern=removal, replacement=replace, x=dir)
    new_path <- file.path(basedir, new_dir)
    ## And rename the directory
    ## mv_cmd <- paste0("mv ", path, " ", new_path)
    mv_cmd <- glue::glue("mv {path} {new_path}")
    message("moving orgdb: ", mv_cmd)
    system(mv_cmd)
    ## Collect the text files in the new package and remove all -like instances in them
    ## find_cmd <- paste0("perl -p -i -e 's/",
    ##                    removal, "/", replace,
    ##                    "/g' $(find ", new_path,
    ##                    " -type f | grep -v 'sqlite' | grep -v 'zzz' | grep -v 'rda')")
    find_cmd <- glue::glue(
      "perl -p -i -e 's/{removal}/{replace}/g' \\
      $(find {new_path} -type f | grep -v 'sqlite' | grep -v 'zzz' | grep -v 'rda')")
    message("rewriting orgdb files: ", find_cmd)
    system(find_cmd)

    if (isTRUE(sqlite)) {
      ## Move the sqlite file, now the directory has been renamed.
      ## So when we go to move it we need to take that into account.
      old_sqlite_base <- gsub(pattern=".db", replacement="", x=dir)
      sqlite_basename <- basename(dir)
      sqlite_basename <- gsub(pattern=".sqlite", replacement="", x=sqlite_basename)
      old_sqlite_file <- file.path(new_dir, "inst", "extdata", glue::glue("{old_sqlite_base}.sqlite"))
      old_sqlite <- file.path(basedir, old_sqlite_file)
      new_sqlite_file <- gsub(pattern=removal, replacement=replace, x=old_sqlite_file)
      new_sqlite <- file.path(basedir, new_sqlite_file)
      ## sqlite_mv_cmd <- paste0("mv ", old_sqlite, " ", new_sqlite)
      sqlite_mv_cmd <- glue::glue("mv {old_sqlite} new_sqlite")
      message("moving sqlite file: ", sqlite_mv_cmd)
      system(sqlite_mv_cmd)
      ## orgdb_dir <- new_dir
      new_pkg_name <- gsub(pattern=removal, replacement=replace, x=sqlite_basename)
      ## Update the orgdb sqlite file to reflect the new name
      ## final_sqlite_cmd <- paste0("chmod +w ", new_sqlite, " ; sqlite3 ", new_sqlite,
      ##                            " \"UPDATE metadata SET value='", new_pkg_name,
      ##                            "' WHERE name='SPECIES';\" ; chmod -w ", new_sqlite)
      final_sqlite_cmd <- glue::glue(
        "chmod +w {new_sqlite}; sqlite3 {new_sqlite} \\
        \"UPDATE metadata SET value='{new_pkg_name}' WHERE name='SPECIES';\";\\
        chmod -w {new_sqlite}")
      message("rewriting sqlite db:", final_sqlite_cmd)
      system(final_sqlite_cmd)
    }
  }
  return(new_path)
}

#' Generate standardized package names for the various eupathdb species.
#'
#' This is a surprisingly difficult problem.  Many species names in the eupathdb
#' have odd characters in the species suffix which defines the strain ID.  Many
#' of these peculiarities result in packages which are non-viable for
#' installation.  Thus this function attempts to filter them out and result in
#' consistent, valid package names.  They are not exactly the same in format as
#' other orgdb/txdb/etc packages, as I include in them a field for the eupathdb
#' version used; but otherwise they should be familiar to any user of the sqlite
#' based organism packages.
#'
#' The default argument for this function shows the funniest one I have found so
#' far thanks to the hash character in the strain definition.
#'
#' @param entry A metadatum entry.
#' @param version Choose a specific version of the eupathdb, only really useful
#'   when downloading files.
#' @return List of package names and some booleans to see if they have already
#'   been installed.
#' @author atb
#' @export
get_eupath_pkgnames <- function(entry, version=NULL) {
  species <- entry[["Species"]]
  version_string <- glue::glue(".v{entry[['SourceVersion']]}")
  if (!is.null(version)) {
    version_string <- glue::glue(".v{version}")
  }
  provider <- tolower(entry[["DataProvider"]])
  taxa <- make_taxon_names(entry)
  first_char <- strsplit(taxa[["genus"]], split="")[[1]][[1]]
  pkg_list <- list(
    "bsgenome" = glue::glue("BSGenome.{taxa[['taxon']]}{version_string}"),
    "bsgenome_installed" = FALSE,
    "granges" = glue::glue("GRanges.{taxa[['taxon']]}{version_string}.rda"),
    "organismdbi" = glue::glue("{provider}.{taxa[['taxon']]}{version_string}"),
    "organismdbi_installed" = FALSE,
    "orgdb" = glue::glue("org.{first_char}{taxa[['species_strain']]}{version_string}.eg.db"),
    "orgdb_installed" = FALSE,
    "txdb" = glue::glue("TxDb.{taxa[['genus']]}.{taxa[['species_strain']]}.\\
                  {entry[['DataProvider']]}{version_string}"),
    "txdb_installed" = FALSE
  )
  inst <- as.data.frame(installed.packages())
  if (pkg_list[["bsgenome"]] %in% inst[["Package"]]) {
    pkg_list[["bsgenome_installed"]] <- TRUE
  }
  if (pkg_list[["organismdbi"]] %in% inst[["Package"]]) {
    pkg_list[["organismdbi_installed"]] <- TRUE
  }
  if (pkg_list[["orgdb"]] %in% inst[["Package"]]) {
    pkg_list[["orgdb_installed"]] <- TRUE
  }
  if (pkg_list[["txdb"]] %in% inst[["Package"]]) {
    pkg_list[["txdb_installed"]] <- TRUE
  }
  return(pkg_list)
}

#' Generate a BSgenome package from the eupathdb.
#'
#' Since we go to the trouble to try and generate nice orgdb/txdb/organismdbi
#' packages, it seems to me that we ought to also be able to make a readable
#' genome package.  I should probably use some of the logic from this to make
#' the organismdbi generator smarter.
#'
#' @param entry  Single eupathdb metadata entry.
#' @param version Which version of the eupathdb to use for creating the BSGenome?
#' @param dir  Working directory.
#' @param reinstall  Rewrite an existing package directory.
#' @param ... Extra arguments for downloading metadata when not provided.
#' @return  List of package names generated (only 1).
#' @author atb
#' @export
make_eupath_bsgenome <- function(entry, version=NULL, dir="EuPathDB",
                                 reinstall=FALSE, ...) {
  arglist <- list(...)
  author <- "Ashton Trey Belew <abelew@umd.edu>"
  if (!is.null(arglist[["author"]])) {
    author <- arglist[["author"]]
  }
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  species <- entry[["Species"]]
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["bsgenome"]]
  if (pkgname %in% installed.packages() & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "bsgenome_name" = pkgname
    )
    return(retlist)
  }

  ## Check that a directory exists to leave the final package
  dir <- file.path(dir)
  if (!file.exists(dir)) {
    tt <- dir.create(dir, recursive=TRUE)
  }
  ## Check for an incomplete installation directory and clear it out.
  if (file.exists(pkgname)) {
    final_deleted <- unlink(x=pkgname, recursive=TRUE, force=TRUE)
  }

  ## Figure out the version numbers and download urls.
  db_version <- entry[["SourceVersion"]]
  if (!is.null(version)) {
    db_version <- version
  }
  fasta_start <- entry[["SourceUrl"]]
  fasta_starturl <- sub(pattern="gff",
                        replacement="fasta",
                        x=fasta_start,
                        perl=TRUE)
  fasta_url <- sub(pattern="\\.gff", replacement="_Genome\\.fasta",
                   x=fasta_starturl)
  fasta_hostname <- sub(pattern="https://(.*)\\.org.*$",
                        replacement="\\1",
                        x=fasta_start)
  ## genome_filename <- file.path(dir, paste0(pkgname, ".fasta"))
  genome_filename <- file.path(dir, glue::glue("{pkgname}.fasta"))

  ## Find a spot to dump the fasta files
  bsgenome_dir <- file.path(dir, pkgname)
  if (!file.exists(bsgenome_dir)) {
    created <- dir.create(bsgenome_dir, recursive=TRUE)
  }
  ## Download them to this directory.
  downloaded <- download.file(url=fasta_url, destfile=genome_filename, quiet=FALSE)
  ## And extract all the individual chromosomes into this directory.
  input <- Biostrings::readDNAStringSet(genome_filename)
  output_list <- list()
  sequence_names <- "c("
  message("Writing chromosome files, this is slow for fragmented scaffolds.")
  show_progress <- interactive() && is.null(getOption("knitr.in.progress"))
  if (isTRUE(show_progress)) {
    bar <- utils::txtProgressBar(style=3)
  }
  for (index in 1:length(input)) {
    if (isTRUE(show_progress)) {
      pct_done <- index / length(input)
      setTxtProgressBar(bar, pct_done)
    }
    chr <- names(input)[index]
    chr_name <- strsplit(chr, split=" ")[[1]][1]
    ## chr_file <- file.path(bsgenome_dir, paste0(chr_name, ".fa"))
    chr_file <- file.path(bsgenome_dir, glue::glue("{chr_name}.fa"))
    output <- Biostrings::writeXStringSet(input[index], chr_file, append=FALSE,
                                          compress=FALSE, format="fasta")
    output_list[[chr_name]] <- chr_file
    sequence_names <- paste0(sequence_names, '"', chr_name, '", ')
  }
  if (isTRUE(show_progress)) {
    close(bar)
  }
  sequence_names <- gsub(pattern=", $", replacement=")", x=sequence_names)

  ## Now start creating the DESCRIPTION file
  desc_file <- file.path(bsgenome_dir, "DESCRIPTION")
  descript <- desc::description$new("!new")
  descript$set(Package=pkgname)
  ## title <- paste0(taxa[["genus"]], " ", taxa[["species"]], " strain ", taxa[["strain"]],
  ##                 " version ", db_version)
  title <- glue::glue("{taxa[['genus']]} {taxa[['species']]} strain {taxa[['strain']]} \\
                version {db_version}")

  descript$set(Title=title)
  descript$set(Author=author)
  version_string <- format(Sys.time(), "%Y.%m")
  descript$set(Version=version_string)
  descript$set(Maintainer=author)
  descript$set(Description=glue::glue("A full genome from the eupathdb for {title}."))
  descript$set(License="Artistic-2.0")
  descript$set(URL="https://eupathdb.org")
  descript$set(BugReports="https://github.com/elsayed-lab")
  descript$set(seqs_srcdir=bsgenome_dir)
  descript$set(seqnames=sequence_names)
  descript$set(organism=taxa[["taxon"]])
  descript$set(common_name=taxa[["genus_species"]])
  descript$set(provider=fasta_hostname)
  descript$set(provider_version=glue::glue("{fasta_hostname} {db_version}"))
  descript$set(release_date=format(Sys.time(), "%Y%m%d"))
  descript$set(BSgenomeObjname=glue::glue("{taxa[['genus_species']]}_{taxa[['strain']]}"))
  descript$set(release_name=as.character(db_version))
  descript$set(organism_biocview=glue::glue("{taxa[['genus_species']]}_{taxa[['strain']]}"))
  descript$del("LazyData")
  descript$del("Authors@R")
  descript$del("URL")
  descript$del("BugReports")
  descript$del("Encoding")
  description_file <- file.path(bsgenome_dir, "DESCRIPTION")
  descript$write(description_file)

  ## Generate the package, this puts it into the cwd.
  message("Starting forgeBSgenomeDataPkg().")
  tt <- requireNamespace("Biostrings")
  ## Otherwise I get error in cannot find uniqueLetters (this seems to be a new development)
  library(Biostrings)
  annoying <- try(BSgenome::forgeBSgenomeDataPkg(description_file, verbose=FALSE))

  inst <- NULL
  if (class(annoying) != "try-error") {
    inst <- try(devtools::install(pkgname, quiet=TRUE))
  }

  retlist <- list()
  if (class(inst) != "try-error" & !is.null(inst)) {
    retlist[["bsgenome_name"]] <- pkgname
    ## Clean up a little.
    deleted <- unlink(x=bsgenome_dir, recursive=TRUE, force=TRUE)
    built <- try(devtools::build(pkgname, quiet=TRUE))
    if (class(built) != "try-error") {
      final_path <- move_final_package(bsgenome_dir, type="bsgenome", dir=dir)
      final_deleted <- unlink(x=pkgname, recursive=TRUE, force=TRUE)
    }
  } else {
    retlist <- inst
  }

  return(retlist)
}

#' Create an organismDbi instance for an eupathdb organism.
#'
#' The primary goal of an organismdbi instance is to provide a series of links
#' between an orgdb, txdb, and other relevant annotation packages
#' (reactome/go/etc).  In its current iteration, this function brings together a
#' couple columns from the orgdb, txdb, GO.db, and reactome.db.
#'
#' @param entry A row from the eupathdb metadataframe.
#' @param version Which version of the eupathdb to use for creating this package?
#' @param dir Directory in which to build the packages.
#' @param reinstall Overwrite existing data files?
#' @param kegg_abbreviation  For when we cannot automagically find the kegg species id.
#' @param exclude_join I had a harebrained idea to automatically set up the
#'   joins between columns of GO.db/reactome.db/orgdb/txdb objects.  This
#'   variable is intended to exclude columns with common IDs that might
#'   multi-match spuriously -- I think in the end I killed the idea though,
#'   perhaps this should be removed or resurrected.
#' @return  The result of attempting to install the organismDbi package.
#' @author  Keith Hughitt, modified by atb.
#' @export
make_eupath_organismdbi <- function(entry=NULL, version=NULL, dir="EuPathDB", reinstall=FALSE,
                                    kegg_abbreviation=NULL, exclude_join="ENTREZID") {
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["organismdbi"]]
  if (isTRUE(pkgnames[["organismdbi_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "organdb_name" = pkgname)
    return(retlist)
  }
  orgdb_name <- pkgnames[["orgdb"]]
  txdb_name <- pkgnames[["txdb"]]
  orgdb_ret <- make_eupath_orgdb(entry, version=version, dir=dir,
                                 kegg_abbreviation=kegg_abbreviation, reinstall=reinstall)
  if (is.null(orgdb_ret)) {
    return(NULL)
  }
  txdb_ret <- make_eupath_txdb(entry, version=version, dir=dir, reinstall=reinstall)
  if (is.null(txdb_ret)) {
    return(NULL)
  }

  tt <- requireNamespace(orgdb_name)
  tt <- requireNamespace(txdb_name)
  test <- do.call("library", as.list(orgdb_name))
  test <- do.call("library", as.list(txdb_name))
  organism <- taxa[["taxon"]]
  required <- requireNamespace("OrganismDbi")

  message("Joining the txdb and orgdb objects.")
  count <- 0
  graph_data <- list()
  geneids_found <- "GID" %in% AnnotationDbi::keytypes(get(orgdb_name)) &&
    "GENEID" %in% AnnotationDbi::keytypes(get(txdb_name))
  if (isTRUE(geneids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(orgdb="GID",  txdb="GENEID")
    names(graph_data[[name]]) <- c(orgdb_name, txdb_name)
  }
  required <- requireNamespace("GO.db")
  required <- try(attachNamespace("GO.db"), silent=TRUE)
  ## FIXME Theoretically we should no longer have columns with names like
  ## GO_GO
  orgdb_go_col <- "GO_GO_ID"
  goids_found <- "GOID" %in% AnnotationDbi::keytypes(get("GO.db")) &&
    orgdb_go_col %in% AnnotationDbi::keytypes(get(orgdb_name))
  if (isTRUE(goids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(GO.db="GOID", orgdb=orgdb_go_col)
    names(graph_data[[name]]) <- c("GO.db", orgdb_name)
  }
  ## FIXME Theoretically we should no longer have columns with names like
  ## PATHWAY_PATHWAY
  required <- requireNamespace("reactome.db")
  required <- try(attachNamespace("reactome.db"), silent=TRUE)
  orgdb_path_col <- "PATHWAY_PATHWAY"
  reactomeids_found <- "REACTOMEID" %in% AnnotationDbi::keytypes(get("reactome.db")) &&
    orgdb_path_col %in% AnnotationDbi::keytypes(get(orgdb_name))
  if (isTRUE(reactomeids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(reactome.db="REACTOMEID", orgdb=orgdb_path_col)
    names(graph_data[[name]]) <- c("reactome.db", orgdb_name)
  }

  author <- as.character(entry[["Maintainer"]])
  maintainer <- as.character(entry[["Maintainer"]])
  final_dir <- file.path(dir, "organismdbi", pkgname)
  if (file.exists(final_dir)) {
    if (isTRUE(reinstall)) {
      unlinkret <- unlink(x=final_dir, recursive=TRUE)
    } else {
      if (file.exists(glue::glue("{final_dir}.bak"))) {
        unlinkret <- unlink(x=glue::glue("{final_dir}.bak"), recursive=TRUE)
      }
      renamed <- file.rename(from=final_dir, to=glue::glue("{final_dir}.bak"))
    }
  }

  tmp_pkg_dir <- file.path(dir)
  if (!file.exists(tmp_pkg_dir)) {
    dir.create(tmp_pkg_dir, recursive=TRUE)
  }
  version_string <- format(Sys.time(), "%Y.%m")
  organdb <- OrganismDbi::makeOrganismPackage(
                            pkgname=pkgname,
                            graphData=graph_data,
                            organism=organism,
                            version=version_string,
                            maintainer=maintainer,
                            author=author,
                            destDir=tmp_pkg_dir,
                            license="Artistic-2.0")
  organdb_path <- clean_pkg(final_dir)
  organdb_path <- clean_pkg(organdb_path, removal="_", replace="", sqlite=FALSE)
  organdb_path <- clean_pkg(organdb_path, removal="_like", replace="like", sqlite=FALSE)
  if (class(organdb) == "list") {
    inst <- try(devtools::install(organdb_path))
    if (class(inst) != "try-error") {
      built <- try(devtools::build(organdb_path, quiet=TRUE))
      if (class(built) != "try-error") {
        final_deleted <- unlink(x=organdb_path, recursive=TRUE, force=TRUE)
      }
    }
  }
  final_organdb_name <- basename(organdb_path)
  final_organdb_path <- move_final_package(organdb_path, type="organismdbi", dir=dir)
  retlist <- list(
    "orgdb_name" = orgdb_name,
    "txdb_name" = txdb_name,
    "organdb_name" = final_organdb_name)
  tt <- unloadNamespace(orgdb_name)
  tt <- unloadNamespace(txdb_name)
  return(retlist)
}

#' Create an orgdb SQLite database from the tables in eupathdb.
#'
#' This function has passed through multiple iterations as the preferred
#' method(s) for accessing data in the eupathdb has changed.  It currently uses
#' my empirically defined set of queries against the eupathdb webservices.  As a
#' result, I have made some admittedly bizarre choices when creating the
#' queries.  Check through eupath_webservices.r for some amusing examples of how
#' I have gotten around the idiosyncrasies in the eupathdb.
#'
#' @param entry If not provided, then species will get this, it contains all the information.
#' @param dir Where to put all the various temporary files.
#' @param version Which version of the eupathdb to use for creating this package?
#' @param kegg_abbreviation If known, provide the kegg abbreviation.
#' @param reinstall Re-install an already existing orgdb?
#' @param overwrite Overwrite a partial installation?
#' @param do_go Create the gene ontology table?
#' @param do_orthologs Create the gene ortholog table?
#' @param do_interpro Create the interpro table?
#' @param do_pathway Create the pathway table?
#' @param do_kegg Attempt to create the kegg table?
#' @return Currently only the name of the installed package.  This should
#'   probably change.
#' @author Keith Hughitt with significant modifications by atb.
#' @export
make_eupath_orgdb <- function(entry=NULL, dir="EuPathDB", version=NULL,
                              kegg_abbreviation=NULL, reinstall=FALSE, overwrite=FALSE,
                              do_go=TRUE, do_orthologs=TRUE, do_interpro=TRUE,
                              do_pathway=TRUE, do_kegg=TRUE) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["orgdb"]]
  if (isTRUE(pkgnames[["orgdb_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "orgdb_name" = pkgname)
    return(retlist)
  }

  if (!file.exists(dir)) {
    created <- dir.create(dir, recursive=TRUE)
  }

  if (is.null(kegg_abbreviation)) {
    kegg_abbreviation <- get_kegg_orgn(glue::glue("{taxa[['genus']]} {taxa[['species']]}"))
    if (length(kegg_abbreviation) == 0) {
      do_kegg <- FALSE
    }
  }

  chosen_provider <- entry[["DataProvider"]]
  chosen_species <- entry[["Species"]]
  gene_table <- try(post_eupath_annotations(entry, dir=dir, overwrite=overwrite))
  if (class(gene_table) == "try-error") {
    gene_table <- data.frame()
    warning("Unable to create an orgdb for this species.")
    return(NULL)
  }
  if (nrow(gene_table) == 0) {
    gene_table <- data.frame()
    warning("Unable to create an orgdb for this species.")
    return(NULL)
  }

  gene_ids <- gene_table[["GID"]]
  go_table <- data.frame()
  if (isTRUE(do_go)) {
    go_table <- try(post_eupath_go_table(entry, dir=dir, overwrite=overwrite))
    if (class(go_table) == "try-error") {
      go_table <- data.frame()
    }
  }

  ortholog_table <- data.frame()
  if (class(do_orthologs)[1] == "character" & do_orthologs == "get") {
    ortholog_table <- try(get_orthologs_all_genes(entry=entry, dir=dir, gene_ids=gene_ids))
    if (class(ortholog_table)[1] == "try-error") {
      ortholog_table <- data.frame()
    }
  } else if (isTRUE(do_orthologs)) {
    ortholog_table <- try(post_eupath_ortholog_table(entry=entry, dir=dir, overwrite=overwrite))
    if (class(ortholog_table)[1] == "try-error") {
      ## Try again on the fallback table.
      ortholog_table <- try(post_eupath_ortholog_table(entry=entry, dir=dir,
                                                       overwrite=overwrite, table="Orthologs"))
      if (class(ortholog_table)[1] == "try-error") {
        ortholog_table <- data.frame()
      }
    }
  }

  interpro_table <- data.frame()
  if (isTRUE(do_interpro)) {
    interpro_table <- try(post_eupath_interpro_table(entry=entry, dir=dir, overwrite=overwrite))
    if (class(interpro_table) == "try-error") {
      interpro_table <- data.frame()
    }
  }

  pathway_table <- data.frame()
  if (isTRUE(do_pathway)) {
    pathway_table <- try(post_eupath_pathway_table(entry=entry, dir=dir, overwrite=overwrite))
    if (class(pathway_table) == "try-error") {
      pathway_table <- data.frame()
    }
  }

  kegg_table <- data.frame()
  if (isTRUE(do_kegg)) {
    kegg_table <- try(load_kegg_annotations(species=taxa[["genus_species"]],
                                            flatten=FALSE,
                                            abbreviation=kegg_abbreviation))
    if (class(kegg_table) == "try-error" | nrow(kegg_table) == 0) {
      kegg_table <- data.frame()
    } else {
      colnames(kegg_table) <- glue::glue("KEGGREST_{toupper(colnames(kegg_table))}")
      colnames(kegg_table)[[1]] <- "GID"
    }
  }

  chromosome_table <- gene_table[, c("GID", "ANNOT_SEQUENCE_ID")]
  colnames(chromosome_table) <- c("GID", "CHR_ID")
  type_table <- gene_table[, c("GID", "ANNOT_GENE_TYPE")]
  colnames(type_table) <- c("GID", "GENE_TYPE")

  ## Compile list of arguments for makeOrgPackage call
  version_string <- format(Sys.time(), "%Y.%m")
  orgdb_args <- list(
    "gene_info" = gene_table,
    "chromosome" = chromosome_table,
    "type" = type_table,
    "version" = version_string,
    "author" = entry[["Maintainer"]],
    "maintainer" = entry[["Maintainer"]],
    "tax_id" = as.character(entry[["TaxonomyId"]]),
    "genus" = taxa[["genus"]],
    "species" = glue::glue("{taxa[['species_strain']]}.v{entry[['SourceVersion']]}"),
    "outputDir" = dir)

  ## add non-empty tables
  if (is.null(go_table)) {
    message("This should not be possible, but the go table is still null.")
  } else if (nrow(go_table) > 0) {
    orgdb_args[["go"]] <- go_table
  }
  if (is.null(ortholog_table)) {
    message("This should not be possible, but the ortholog table is still null.")
  } else if (nrow(ortholog_table) > 0) {
    orgdb_args[["orthologs"]] <- ortholog_table
  }
  if (is.null(interpro_table)) {
    message("This should not be possible, but the interpro table is still null.")
  } else if (nrow(interpro_table) > 0) {
    orgdb_args[["interpro"]] <- interpro_table
  }
  if (is.null(pathway_table)) {
    message("This should not be possible, but the pathway table is still null.")
  } else if (nrow(pathway_table) > 0) {
    orgdb_args[["pathway"]] <- pathway_table
  }
  if (is.null(kegg_table)) {
    message("This should not be possible, but the kegg table is still null.")
  } else if (nrow(kegg_table) > 0) {
    orgdb_args[["kegg"]] <- kegg_table
  }

  ## Make sure no duplicated stuff snuck through, or makeOrgPackage throws an error.
  ## Make sure that every GID field is character, too
  ## -- otherwise you get 'The type of data in the 'GID'
  ## columns must be the same for all data.frames.'
  used_columns <- c()
  for (i in 1:length(orgdb_args)) {
    argname <- names(orgdb_args)[i]
    if (class(orgdb_args[[i]])[1] == "data.frame") {
      ## Make sure that the column names in this data frame are unique.
      ## This starts at 2 because the first column should _always_ by 'GID'
      for (cn in 2:length(colnames(orgdb_args[[i]]))) {
        colname <- colnames(orgdb_args[[i]])[cn]
        if (colname %in% used_columns) {
          new_colname <- glue::glue("{toupper(argname)}_{colname}")
          colnames(orgdb_args[[i]])[cn] <- new_colname
          used_columns <- c(used_columns, new_colname)
        } else {
          used_columns <- c(used_columns, colname)
        }
      }
      ## First swap out NA to ""
      na_tmp <- orgdb_args[[i]]
      na_set <- is.na(na_tmp)
      na_tmp[na_set] <- ""
      orgdb_args[[i]] <- na_tmp
      ## Then remove duplicated elements.
      orgdb_dups <- duplicated(orgdb_args[[i]])
      if (sum(orgdb_dups) > 0) {
        tmp <- orgdb_args[[i]]
        tmp <- tmp[!orgdb_dups, ]
        orgdb_args[[i]] <- tmp
      }
      ## Finally, make sure all GID columns are characters
      orgdb_args[[i]][["GID"]] <- as.character(orgdb_args[[i]][["GID"]])
    } ## End checking for data.frames
  }

  ## The following lines are because makeOrgPackage fails stupidly if the directory exists.
  backup_path <- file.path(dir, glue::glue("{pkgname}.bak"))
  first_path <- file.path(dir, pkgname)
  if (file.exists(backup_path)) {
    message(backup_path, " already exists, deleting it.")
    ret <- unlink(backup_path, recursive=TRUE)
  }
  if (file.exists(first_path)) {
    message(first_path, " already exists, backing it up.")
    ret <- file.rename(first_path, backup_path)
  }

  lib_result <- requireNamespace("AnnotationForge")
  att_result <- try(attachNamespace("AnnotationForge"), silent=TRUE)
  message(sprintf("- Calling makeOrgPackage for %s", entry[["Species"]]))
  orgdb_path <- try(do.call("makeOrgPackage", orgdb_args))
  if (class(orgdb_path) == "try-error") {
    return(NULL)
  }

  ## Fix name in sqlite metadata table
  dbpath <- file.path(
    orgdb_path, "inst/extdata", sub(".db", ".sqlite", basename(orgdb_path)))
  message(sprintf("- Fixing sqlite Orgdb sqlite database %s", dbpath))

  ## make sqlite database editable
  Sys.chmod(dbpath, mode="0644")
  db <- RSQLite::dbConnect(RSQLite::SQLite(), dbname=dbpath)
  ## update SPECIES field
  query <- sprintf('UPDATE metadata SET value="%s" WHERE name="SPECIES";', entry[["Species"]])
  sq_result <- RSQLite::dbSendQuery(conn=db, query)
  cleared <- RSQLite::dbClearResult(sq_result)
  ## update ORGANISM field
  query <- sprintf('UPDATE metadata SET value="%s" WHERE name="ORGANISM";', entry[["Species"]])
  sq_result <- RSQLite::dbSendQuery(conn=db, query)
  cleared <- RSQLite::dbClearResult(sq_result)
  ## lock it back down
  Sys.chmod(dbpath, mode="0444")
  closed <- RSQLite::dbDisconnect(db)

  ## Clean up any strangeness in the DESCRIPTION file
  orgdb_path <- clean_pkg(orgdb_path)
  orgdb_path <- clean_pkg(orgdb_path, removal="_", replace="")
  orgdb_path <- clean_pkg(orgdb_path, removal="_like", replace="like")
  testthat::expect_equal(first_path, orgdb_path)
  ## And install the resulting package.
  inst <- try(devtools::install(orgdb_path))
  if (class(inst) != "try-error") {
    built <- try(devtools::build(orgdb_path, quiet=TRUE))
    if (class(built) != "try-error") {
      final_path <- move_final_package(orgdb_path, type="orgdb", dir=dir)
      final_deleted <- unlink(x=orgdb_path, recursive=TRUE, force=TRUE)
    }
  }

  ## Probably should return something more useful/interesting than this, perhaps
  ## the dimensions of the various tables in the orgdb?
  ## return the path to the sqlite database
  retlist <- list(
    "orgdb_name" = pkgname
  )
  return(retlist)
}

#' Generate an EuPathDB organism TxDb package.
#'
#' This will hopefully create a txdb package and granges savefile for a single
#' species in the eupathdb.  This depends pretty much entirely on the successful
#' download of a gff file from the eupathdb.
#'
#' @param entry  One row from the organism metadata.
#' @param version  Which version of the eupathdb to use for creating this package?
#' @param dir  Base directory for building the package.
#' @param reinstall  Overwrite an existing installed package?
#' @return TxDb instance name.
#' @author Keith Hughitt with significant modifications by atb.
#' @export
make_eupath_txdb <- function(entry=NULL, dir="EuPathDB", version=NULL, reinstall=FALSE) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }

  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["txdb"]]

  input_gff <- file.path(dir, glue::glue("{pkgname}.gff"))
  if (!file.exists(input_gff)) {
    gff_url <- gsub(pattern="^http:", replacement="https:", x=entry[["SourceUrl"]])
    tt <- download.file(url=gff_url, destfile=input_gff,
                        method="curl", quiet=FALSE)
  }
  if (!isTRUE(tt)) {
    stop("Failed to download the gff file from: ", gff_url, ".")
  }
  ## It appears that sometimes I get weird results from this download.file()
  ## So I will use the later import.gff3 here to ensure that the gff is actually a gff.
  granges_name <- make_eupath_granges(entry=entry, dir=dir)
  final_granges_path <- move_final_package(granges_name, type="granges", dir=dir)
  granges_variable <- gsub(pattern="\\.rda$", replacement="", x=granges_name)

  if (isTRUE(pkgnames[["txdb_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "gff" = input_gff,
      "txdb_name" = pkgname)
    return(retlist)
  }

  chr_entries <- read.delim(file=input_gff, header=FALSE, sep="")
  chromosomes <- chr_entries[["V1"]] == "##sequence-region"
  chromosomes <- chr_entries[chromosomes, c("V2", "V3", "V4")]
  colnames(chromosomes) <- c("ID", "start", "end")
  chromosome_info <- data.frame(
    "chrom" = chromosomes[["ID"]],
    "length" = as.numeric(chromosomes[["end"]]),
    "is_circular" = NA,
    stringsAsFactors=FALSE)

  txdb_metadata <- as.data.frame(t(entry))
  txdb_metadata[["name"]] <- rownames(txdb_metadata)
  colnames(txdb_metadata) <- c("value", "name")
  txdb_metadata <- txdb_metadata[, c("name", "value")]
  txdb <- try(GenomicFeatures::makeTxDbFromGFF(
                                 file=input_gff,
                                 format="gff",
                                 chrominfo=chromosome_info,
                                 dataSource=entry[["SourceUrl"]],
                                 organism=glue::glue("{taxa[['genus']]} {taxa[['species']]}"),
                                 ## metadata=t(entry))
                                 ))
  if (class(txdb)[1] == "try-error") {
    ## Perhaps it is an invalid taxonomy ID?
    txdb <- try(GenomicFeatures::makeTxDbFromGFF(
                                   taxonomyId=32644, ## 32644 is unidentified according to:
                                   ## https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=32644
                                   file=input_gff,
                                   format="gff",
                                   chrominfo=chromosome_info,
                                   dataSource=entry[["SourceUrl"]],
                                   organism=glue::glue("{taxa[['genus']]} {taxa[['species']]}"),
                                   ## metadata=t(entry))
                                   ))
  }
  if (class(txdb) == "try-error") {
    message("The txdb creation failed.")
    return(NULL)
  }

  ## This is the section I yanked
  provider <- getMetaDataValue(txdb, "Data source")
  providerVersion <- getTxDbVersion(txdb)
  dbType <- getMetaDataValue(txdb, "Db type")
  authors <- normAuthor(entry[["Maintainer"]], entry[["Maintainer"]])
  template_path <- system.file("txdb-template", package="GenomicFeatures")
  version_string <- format(Sys.time(), "%Y.%m")
  data_source <- getMetaDataValue(txdb, "Data source")
  symvals <- list(
    "PKGTITLE" = glue::glue("Annotation package for {dbType} object(s)"),
    "PKGDESCRIPTION" = glue::glue("Exposes an annotation databases generated from \\
                             {data_source} by exposing these as {dbType} objects"),
    "PKGVERSION" = version_string,
    "AUTHOR" = paste(authors, collapse = ", "),
    "MAINTAINER" = as.character(getMaintainer(authors)),
    "GFVERSION" = getMetaDataValue(txdb,
                                   "GenomicFeatures version at creation time"),
    "LIC" = "Artistic-2.0",
    "DBTYPE" = dbType,
    "ORGANISM" = getMetaDataValue(txdb, "Organism"),
    "SPECIES" = getMetaDataValue(txdb, "Organism"),
    "PROVIDER" = provider,
    "PROVIDERVERSION" = providerVersion,
    "RELEASEDATE" = getMetaDataValue(txdb, "Creation time"),
    "SOURCEURL" = entry[["SourceUrl"]],
    "ORGANISMBIOCVIEW" = gsub(" ", "_", getMetaDataValue(txdb, "Organism")),
    "TXDBOBJNAME" = pkgname)
  if (any(duplicated(names(symvals)))) {
    str(symvals)
    stop("'symvals' contains duplicated symbols")
  }
  is_OK <- sapply(symvals, S4Vectors::isSingleString)
  if (!all(is_OK)) {
    bad_syms <- paste(names(is_OK)[!is_OK], collapse=", ")
    stop("values for symbols ", bad_syms, " are not single strings")
  }
  if (!file.exists(dir)) {
    tt <- dir.create(dir, recursive=TRUE)
  }

  pkg_list <- Biobase::createPackage(pkgname=pkgname, destinationDir=dir,
                                     originDir=template_path, symbolValues=symvals,
                                     unlink=TRUE)
  db_dir <- file.path(dir, pkgname, "inst", "extdata")
  if (!file.exists(db_dir)) {
    tt <- dir.create(db_dir, recursive=TRUE)
  }
  db_path <- file.path(db_dir, paste(pkgname, "sqlite", sep="."))

  obj <- try(AnnotationDbi::saveDb(txdb, file=db_path))
  if (class(obj) == "try-error") {
    warning("Failed to save the txdb object.")
  }
  closed <- try(RSQLite::dbDisconnect(dbconn(obj)), silent=TRUE)

  install_dir <- file.path(dir, pkgname)
  install_dir <- clean_pkg(install_dir)
  install_dir <- clean_pkg(install_dir, removal="_", replace="")
  install_dir <- clean_pkg(install_dir, removal="_like", replace="like")

  inst <- try(devtools::install(install_dir, quiet=TRUE))
  if (class(inst) != "try-error") {
    built <- try(devtools::build(install_dir, quiet=TRUE))
    if (class(built) != "try-error") {
      final_path <- move_final_package(pkgname, type="txdb", dir=dir)
      final_deleted <- unlink(x=install_dir, recursive=TRUE, force=TRUE)
    }
  }

  retlist <- list(
    "object" = txdb,
    "gff" = input_gff,
    "txdb_name" = pkgname,
    "granges_file" = granges_name,
    "granges_variable" = granges_variable)

  return(retlist)
}

#' Generate a GRanges rda savefile from a gff file.
#'
#' There is not too much else to say. This uses import.gff from rtracklayer.
#' I should probably steal my code from hpgltools to make this work for any
#' version of a gff file, but the eupathdb is good about keeping consistent on
#' this front.
#'
#' @param entry Metadatum entry.
#' @param dir Place to put the resulting file(s).
#' @param version Optionally request a specific version of the gff file.
make_eupath_granges <- function(entry=NULL, dir="EuPathDB", version=NULL) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }

  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["txdb"]]

  input_gff <- file.path(dir, glue::glue("{pkgname}.gff"))
  if (!file.exists(input_gff)) {
    gff_url <- gsub(pattern="^http:", replacement="https:", x=entry[["SourceUrl"]])
    tt <- download.file(url=gff_url, destfile=input_gff,
                        method="curl", quiet=FALSE)
  }

  ## Dump a granges object and save it as an rda file.
  granges_result <- rtracklayer::import.gff3(input_gff)
  granges_name <- pkgnames[["granges"]]
  granges_env <- new.env()
  granges_variable <- gsub(pattern="\\.rda$", replacement="", x=granges_name)
  granges_env[[granges_variable]] <- granges_result
  granges_file <- file.path(dir, granges_name)
  save_result <- save(list=ls(envir=granges_env),
                      file=granges_file,
                      envir=granges_env)
  ## import.gff3 appears to be opening 2 connections to the gff file, both are read only.
  ## It is not entirely clear to me, given the semantics of import.gff3, how to close these
  ## connections cleanly, ergo the following.
  extra_connections <- rownames(showConnections())
  for (con in extra_connections) {
    closed <- try(close(getConnection(con)), silent=TRUE)
  }

  return(granges_name)
}

move_final_package <- function(pkgname, type="orgdb", dir="EuPathDB") {
  final_dir <- file.path(dir, type)
  if (!file.exists(final_dir)) {
    dir.create(final_dir, recursive=TRUE)
  }
  pkgname <- basename(pkgname)
  version_string <- format(Sys.time(), "%Y.%m")
  final_filename <- glue::glue("{pkgname}_{version_string}.tar.gz")
  current_path <- file.path(dir, final_filename)
  final_path <- file.path(final_dir, final_filename)
  if (type == "granges") {
    current_path <- file.path(dir, pkgname)
    final_path <- file.path(final_dir, pkgname)
  }
  moved <- file.rename(from=current_path, to=final_path)
  return(final_path)
}

## EOF
