#' Create a series of POST requests which download all the annotation data for a species.
#'
#' The only way I have figured out how to download mass data from the eupathdb
#' is to ask for a raw dump of all available data using the GenesByGeneType
#' WADL.  Therefore, this function iterates over the various sequence types that
#' I have noticed at the eupathdb and does that for each type.
#'
#' @param entry Eupathdb annotation entry.
#' @param build_dir Location to dump the resulting data.
#' @param overwrite Overwrite existing data if it exists?
<<<<<<< HEAD:R/post_eupath_annotations.R
post_eupath_annotations <- function(entry = NULL, overwrite = FALSE, build_dir = "EuPathDB") {
=======
post_eupathdb_annotations <- function(entry = NULL, workdir = "EuPathDB", overwrite = FALSE) {
>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
    if (is.null(entry)) {
        stop("[ERROR] Need an entry from the eupathdb.")
    }

<<<<<<< HEAD:R/post_eupath_annotations.R
    ## Check for output rda directory and create it if necessary
    rdadir <- file.path(build_dir, "rda")
    if (!file.exists(build_dir)) {
        created <- dir.create(build_dir, recursive = TRUE)
    }

    ## Look for an existing savefile and load if we are not overwriting existing data.
    savefile <- file.path(build_dir, glue::glue("{entry[['Genome']]}_annotations.rda"))
=======
    # check for output rda directory and create if needed
    rdadir <- file.path(workdir, "rda")

    if (!file.exists(rdadir)) {
        created <- dir.create(rdadir, recursive = TRUE)
    }

    # check for existing rda save file
    savefile <- file.path(rdadir, glue::glue("{entry[['Genome']]}_annotations.rda"))

>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
    if (file.exists(savefile)) {
        if (isTRUE(overwrite)) {
            removed <- file.remove(savefile)
        } else {
            info(savefile, " already exists! Delete this file if you wish to regenerate it.")
            result <- new.env()
            load(savefile, envir = result)
            result <- result[["result"]]
            return(result)
        }
    }

    ## query body as a structured list
    ## This list was generated by going to:
    ## view-source:http://tritrypdb.org/webservices/GeneQuestions/GenesByMolecularWeight.wadl
    ## scrolling down to the 'o-fields' section, and writing down the most likely
    ## useful column names.
    ## I later came through and wrote a function function to automagically populate this list.
    species <- entry[["TaxonUnmodified"]]
<<<<<<< HEAD:R/post_eupath_annotations.R
    webservice <- entry[["DataProvider"]]
    ## Use a query to find what annotation types are available: protein coding vs. rRNA vs. etc...
    types <- get_eupath_gene_types(webservice = webservice)
    result <- data.frame()

    ## Excepting schistodb, all the services are .orgs which is a .net.
    tld <- "org"
    if (webservice == "schistodb") {
        tld <- "net"
    }
    ## Finalize the URL to query using the webservice, tld, etc.
    service_directory <- prefix_map(webservice)
    ## download_json <- glue::glue("{build_dir}/{species_filename}.json")

    base_url <- glue::glue("https://{webservice}.{tld}/{service_directory}/service/record-types/transcript/searches/GenesByTaxon/reports/standard")
    wanted_columns <- c("primary_key", "wdk_weight", "has_missing_transcripts", "gene_name",
                        "gene_source_id", "gene_previous_ids", "gene_product", "transcript_product",
                        "gene_exon_count", "exon_count", "gene_transcript_count",
                        "three_prime_utr_length", "five_prime_utr_length", "strand", "gene_type",
                        "is_pseudo", "transcript_length", "gene_entrez_id", "uniprot_id",
                        "chromosome", "gene_location_text", "location_text", "sequence_id",
                        "organism", "gene_ortholog_number", "gene_orthomcl_name",
                        "gene_paralog_number", "gene_hts_noncoding_snps",
                        "gene_hts_nonsyn_syn_ratio", "gene_hts_nonsynonymous_snps",
                        "gene_hts_stop_codon_snps", "gene_hts_synonymous_snps",
                        "gene_total_hts_snps", "cds", "transcript_sequence", "protein_sequence",
                        "protein_length", "cds_length", "molecular_weight", "isoelectric_point",
                        "interpro_id", "interpro_description", "pfam_id", "pfam_description",
                        "pirsf_id", "pirsf_description", "prositeprofiles_id",
                        "prositeprofiles_description", "smart_id", "smart_description",
                        "superfamily_id", "superfamily_description", "tigrfam_id",
                        "tigrfam_description", "new_product_name", "tm_count", "signalp_peptide",
                        "signalp_scores", "predicted_go_id_component", "predicted_go_component",
                        "predicted_go_id_function", "predicted_go_function",
                        "predicted_go_id_process", "predicted_go_process",
                        "annotated_go_id_component", "annotated_go_component",
                        "annotated_go_id_function", "annotated_go_function",
                        "annotated_go_id_process", "annotated_go_process", "ec_numbers",
                        "ec_numbers_derived")
    query_body <- list(
        "searchConfig" = list(
            "parameters" = list("organism" = jsonlite::unbox(species)),
            "wdkWeight" = jsonlite::unbox(10)),
        "reportConfig" = list(
            "attributes" = wanted_columns,
            "tables" = list())
    )
    post_json <- jsonlite::toJSON(query_body)
    result <- httr::POST(url = base_url, body = post_json,
                         httr::content_type("application/json"),
                         httr::timeout(1200))
  ## Test the result to see that we actually got data.
  if (result[["status_code"]] == "422") {
      warn(sprintf("API request failed for %s (code = 422): ", entry[["Taxon"]]))
      return(data.frame())
  } else if (result[["status_code"]] == "400") {
      ## likely due to bad formatConfig
      warn(sprintf("API Request failed for %s (code = 400): ", entry[["Taxon"]]))
  } else if (result[["status_code"]] == "404") {
      warn(sprintf("API Request failed for %s (code = 404): ", entry[["Taxon"]]))
  } else if (result[["status_code"]] != "200") {
      warn(sprintf("API Request failed for %s (code = %d): ",
                   entry$Taxon, result[["status_code"]]))
      return(data.frame())
  } else if (length(result[["content"]]) < 100) {
      warn("Very small amount of content returned for :", entry[["Taxon"]])
  }
  cont <- httr::content(result, encoding = "UTF-8", as = "text")
    result <- try(jsonlite::fromJSON(cont, flatten = TRUE))
    if (class(result)[1] == "try-error") {
        stop("There was a parsing failure when reading the metadata.")
    }
    ## Every record contains and id, some fields, and tables.
    records <- result[["records"]]
    colnames(records) <- gsub(pattern = "^attributes\\.", replacement = "", x = colnames(records))
    records <- expand_list_columns(records)

    ## Use a heuristic to figure out numeric columns and set them accordingly.
    cnames <- colnames(records)
    for (i in 1:length(cnames)) {
        cname <- cnames[i]
        column <- records[[cname]]
        idx <- !is.na(column)
        column <- column[idx]
        res <- suppressWarnings(!is.na(as.numeric(as.character(column))))
        if (sum(res) == length(column)) {
            message("Setting ", cname, " to numeric.")
            records[[cname]] <- as.numeric(records[[cname]])
        }
    }

    ## Change entries which say 'N/A' to the actual NA value
    na_idx <- records == "N/A" | records == "NA"
    false_idx <- is.na(records)
    na_idx[false_idx] <- FALSE
    records[na_idx] <- NA

    ## Hopefully the data is consistent now, so let us change the column names
    ## and send the NAs to a contextually sensible value that sqlite will not yell about
    ## e.g. if a column is numeric, set it to 0; if a column is a character, set it to ""
    colnames(records) <- paste0("annot_", colnames(records))
    for (col_num in 1:length(colnames(records))) {
        cname <- colnames(records)[col_num]
        na_idx <- is.na(records[[col_num]])
        if (is.character(records[[col_num]])) {
            records[na_idx, col_num] <- ""
        } else {
            records[na_idx, col_num] <- 0
=======

    # get a list of supported gene types ("protein coding", "snRNA encoding", etc.)
    gene_types <- get_eupathdb_gene_types()

    combined_result <- data.frame()

    # iterate over gene types and query api separately for each one
    for (i in 1:length(gene_types)) {
        gene_type <- gene_types[i]

        info("Querying gene type: ", gene_type, ".")

        # query parameters
        parameters <- list(
            "organism" = jsonlite::unbox(species),
            "geneType" = jsonlite::unbox(gene_type),
            "includePseudogenes" = jsonlite::unbox("Yes"))
        question <- "GeneQuestions.GenesByGeneType"

        # send request
        result <- try(post_eupathdb_raw(entry, question = question,
                                          parameters = parameters, table_name = "annot"), silent = TRUE)

        if ("try-error" %in% class(result)) {
          next
        } else {
          # append query results to combined dataframe
          colnames(result) <- gsub("annot_annotated", "annot", tolower(colnames(result)))
          combined_result <- rbind(combined_result, result)

          info(sprintf("Added %d %s entries to the result.", nrow(result), gene_type))
        }
    }

    ## Get rid of spurious text in the previous IDs column
    if (!is.null(combined_result[["annot_gene_previous_ids"]])) {
        combined_result[["annot_gene_previous_ids"]] <- gsub("^Previous IDs: ", "",
                                                             combined_result[["annot_gene_previous_ids"]])
    }

    all_columns <- colnames(combined_result)

    # fix numeric cols
    numeric_columns <- c(
        "annot_gene_exon_count",
        "annot_gene_transcript_count",
        "annot_gene_ortholog_number",
        "annot_gene_paralog_number",
        "annot_gene_total_hts_snps",
        "annot_gene_hts_nonsynonymous_snps",
        "annot_gene_hts_synonymous_snps",
        "annot_gene_hts_noncoding_snps",
        "annot_gene_hts_stop_codon_snps",
        "annot_gene_hts_nonsyn_syn_ratio",
        "annot_transcript_length",
        "annot_exon_count",
        "annot_protein_length",
        "annot_cds_length",
        "annot_tm_count",
        "annot_molecular_weight",
        "annot_isoelectric_point",
        "annot_trans_found_per_gene_internal",
        "annot_transcript_index_per_gene",
        "annot_wdk_weight",
        "annot_five_prime_utr_length",
        "annot_three_prime_utr_length")

    for (col in all_columns) {
        na_idx <- is.na(combined_result[[col]])

        if (col %in% numeric_columns) {
            if (!is.null(combined_result[[col]])) {
                combined_result[[col]] <- as.numeric(combined_result[[col]])
            }
            if (sum(na_idx) > 0) {
                combined_result[na_idx, col] <- 0
            }
        } else {
            if (sum(na_idx) > 0) {
                combined_result[na_idx, col] <- ""
            }
        }
    }

    # fix factor cols
    factor_columns <- c(
        "annot_chromosome",
        "annot_gene_type",
        "annot_gene_product",
        "annot_transcript_product",
        "annot_organism",
        "annot_is_pseudo",
        "annot_strand")
    for (col in factor_columns) {
<<<<<<< HEAD
        if (!is.null(result[[col]])) {
            result[[col]] <- as.factor(result[[col]])
>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
        }
        ## Cast factor columns explicitly as factors
        test_col <- as.factor(records[[col_num]])
        test_levels <- length(levels(test_col))
        if (test_levels < 50) {
            message("Setting ", cname, " to a factor.")
            records[[col_num]] <- as.factor(records[[col_num]])
        }
    }
=======
        if (!is.null(combined_result[[col]])) {
            combined_result[[col]] <- as.factor(combined_result[[col]])
        }
        na_idx <- is.na(combined_result[[col]])
        if (sum(na_idx) > 0) {
            combined_result[na_idx, col] <- 0
        }
    }
    colnames(combined_result) <- toupper(colnames(combined_result))
>>>>>>> fc81572 (Some more refactoring / fixes)

<<<<<<< HEAD
<<<<<<< HEAD:R/post_eupath_annotations.R
    ## orgdbs seem to like uppercase column names
    colnames(records) <- toupper(colnames(records))

    ## Get rid of duplicated entries
    dup_idx <- duplicated(records)
    if (sum(dup_idx) > 0) {
        message("  Dropped ", sum(dup_idx), " duplicated entries.")
    }
    records <- records[!dup_idx, ]

    message("  Saving ", savefile, " with ", nrow(records), " rows.")
    save(records, file = savefile)
    return(records)
=======
    message("  Saving ", savefile)
=======
    info("Saving ", savefile)
<<<<<<< HEAD
>>>>>>> e0e10d7 (Improvements to logging; few fixes related to previous refactoring)
    save(result, file = savefile)
    return(result)
>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
=======
    save(combined_result, file = savefile)
    return(combined_result)
>>>>>>> fc81572 (Some more refactoring / fixes)
}

#' Attempt to get a list of sequence types.
#'
#' @param webservice choose a service to download from.
<<<<<<< HEAD:R/post_eupath_annotations.R
get_eupath_gene_types <- function(webservice = NULL) {
=======
get_eupathdb_gene_types <- function(webservice = NULL) {
>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
    if (is.null(webservice)) {
        webservice <- "fungidb"
    }
    tld <- "org"
    if (webservice == "schistodb") {
        tld <- "net"
    }
    request_url <- glue::glue("https://{webservice}.{tld}/a/service/record-types/transcript/searches/GenesByGeneType")
    test <- "https://tritrypdb.org/a/service/record-types/transcript/searches/GenesByGeneType"
    request <- curl::curl(request_url)
<<<<<<< HEAD:R/post_eupath_annotations.R
    result <- jsonlite::fromJSON(request_url)
    vocabulary <- result[["searchData"]][["parameters"]][["vocabulary"]]
    types <- vocabulary[[2]][, 1]
    return(types)
=======
    result <- xml2::read_xml(request)

    ##close(request)

    fields <- rvest::xml_nodes(result, xpath = '//*[@name="geneType"]')[[1]] %>%
        xml2::xml_children() %>%
        xml2::xml_attr("value")

    # [1] <doc title="prompt"><![CDATA[Gene type]]></doc>
    # [2] <doc title="help"><![CDATA[Select one or more gene types. Genes returned by this search will have gene \np
    # [3] <doc title="default"><![CDATA[protein coding]]></doc>
    # [4] <doc title="MultiValued">Provide one or more values. Use comma as a delimter.</doc>
    # [5] <option value="protein coding">\n  <doc title="description"><![CDATA[protein coding]]></doc>\n</option>
    # [6] <option value="snRNA encoding">\n  <doc title="description"><![CDATA[snRNA encoding]]></doc>\n</option>
    # ...

    # exclude NA values in first few entries corresponding to "<doc>" elements in the
    # result; it should be possible to modify the xpath query above to only include
    # the desired "<option>" elements, but I haven't had any luck so far..
    fields <- fields[!is.na(fields)]

    return(fields)
>>>>>>> fd9c661 (Doing a bit of re-organizing):R/post_eupathdb_annotations.R
}
