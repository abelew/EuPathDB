#' Cleans up illegal characters in packages generated by make_organismdbi(),
#' make_orgdb(), and make_txdb(). This attempts to fix some of the common
#' problems therein.
#'
#' The primary problem this function seeks to solve is derived from the fact
#' that some species names in the eupathdb contain characters which are not
#' allowed in orgdb/txdb/organismdbi instances.  Thus this invokes a couple of
#' regular expressions in an attempt to make sure these generated packages are
#' actually installable.
#'
#' One thing I should consider is to add some of this logic to my eupath queries
#' rather than perform these clunky modifications to the already-generated
#' packages.
#'
#' @param path  Location for the original Db/Dbi instance.
#' @param removal  String to remove from the instance.
#' @param replace  What to replace removal with, when necessary.
#' @param sqlite  Also modify the sqlite database?
#' @return  A hopefully cleaner OrgDb/TxDb/OrganismDbi sqlite package.
#' @author atb
#' @export
clean_pkg <- function(path, removal="-like", replace="", sqlite=TRUE) {
  ## This is because TxDb creation fails if you have an author like 'abelew <abelew@gmail.com>'
  ##at_cmd <- paste0("sed -i 's/ at /\\@/g' ", path, "/DESCRIPTION")
  basedir <- dirname(path)
  dir <- basename(path)
  full_path <- file.path(basedir, dir)
  ## at_cmd <- paste0("perl -p -i -e 's/ at /\\@/g' ", full_path, "/DESCRIPTION")
  at_cmd <- glue::glue("perl -p -i -e 's/ at /\\@/g' {full_path}/DESCRIPTION")
  message("Rewriting DESCRIPTION: ", at_cmd)
  system(command=at_cmd)
  ## Since I changed @ to at I figured . could be dot too
  ## dot_cmd <- paste0("perl -p -i -e 's/ dot /\\./g' ", full_path, "/DESCRIPTION")
  dot_cmd <- glue::glue("perl -p -i -e 's/ dot /\\./g' {full_path}/DESCRIPTION")
  message("Rewriting DESCRIPTION to remove ' dot ': ", dot_cmd)
  system(dot_cmd)

  new_dir <- dir
  new_path <- file.path(basedir, new_dir)
  if (grepl(pattern=removal, x=dir)) {
    ## Get rid of the -like in the path name
    new_dir <- gsub(pattern=removal, replacement=replace, x=dir)
    new_path <- file.path(basedir, new_dir)
    ## And rename the directory
    ## mv_cmd <- paste0("mv ", path, " ", new_path)
    mv_cmd <- glue::glue("mv {path} {new_path}")
    message("moving orgdb: ", mv_cmd)
    system(mv_cmd)
    ## Collect the text files in the new package and remove all -like instances in them
    ## find_cmd <- paste0("perl -p -i -e 's/",
    ##                    removal, "/", replace,
    ##                    "/g' $(find ", new_path,
    ##                    " -type f | grep -v 'sqlite' | grep -v 'zzz' | grep -v 'rda')")
    find_cmd <- glue::glue(
      "perl -p -i -e 's/{removal}/{replace}/g' \\
      $(find {new_path} -type f | grep -v 'sqlite' | grep -v 'zzz' | grep -v 'rda')")
    message("rewriting orgdb files: ", find_cmd)
    system(find_cmd)

    if (isTRUE(sqlite)) {
      ## Move the sqlite file, now the directory has been renamed.
      ## So when we go to move it we need to take that into account.
      old_sqlite_base <- gsub(pattern=".db", replacement="", x=dir)
      sqlite_basename <- basename(dir)
      sqlite_basename <- gsub(pattern=".sqlite", replacement="", x=sqlite_basename)
      old_sqlite_file <- file.path(new_dir, "inst", "extdata", glue::glue("{old_sqlite_base}.sqlite"))
      old_sqlite <- file.path(basedir, old_sqlite_file)
      new_sqlite_file <- gsub(pattern=removal, replacement=replace, x=old_sqlite_file)
      new_sqlite <- file.path(basedir, new_sqlite_file)
      ## sqlite_mv_cmd <- paste0("mv ", old_sqlite, " ", new_sqlite)
      sqlite_mv_cmd <- glue::glue("mv {old_sqlite} new_sqlite")
      message("moving sqlite file: ", sqlite_mv_cmd)
      system(sqlite_mv_cmd)
      ## orgdb_dir <- new_dir
      new_pkg_name <- gsub(pattern=removal, replacement=replace, x=sqlite_basename)
      ## Update the orgdb sqlite file to reflect the new name
      ## final_sqlite_cmd <- paste0("chmod +w ", new_sqlite, " ; sqlite3 ", new_sqlite,
      ##                            " \"UPDATE metadata SET value='", new_pkg_name,
      ##                            "' WHERE name='SPECIES';\" ; chmod -w ", new_sqlite)
      final_sqlite_cmd <- glue::glue(
        "chmod +w {new_sqlite}; sqlite3 {new_sqlite} \\
        \"UPDATE metadata SET value='{new_pkg_name}' WHERE name='SPECIES';\";\\
        chmod -w {new_sqlite}")
      message("rewriting sqlite db:", final_sqlite_cmd)
      system(final_sqlite_cmd)
    }
  }
  message("Finished clean_pkg.")
  return(new_path)
}

#' Given 2 species names from the eupathdb, make orthology tables betwixt them.
#'
#' The eupathdb provides such a tremendous wealth of information.  For me
#' though, it is difficult sometimes to boil it down into just the bits of
#' comparison I want for 1 species or between 2 species.  A singularly common
#' question I am asked is: "What are the most similar genes between species x
#' and y among these two arbitrary parasites?"  There are lots of ways to poke
#' at this question: run BLAST/fasta36, use biomart, query the ortholog tables
#' from the eupathdb, etc.  However, in all these cases, it is not trivial to
#' ask the next question:  What about: a:b and b:a?
#' This function attempts to address that for the case of two eupath species
#' from the same domain. (tritrypdb/fungidb/etc.)  It does however assume that
#' the sqlite package has been installed locally, if not it suggests you run the
#' make_organismdbi function in order to do that.
#'
#' One other important caveat: this function assumes queries in the format
#' 'table_column' where in this particular instance, the table is further
#' assumed to be the ortholog table.
#'
#' @param db  Species name (subset) from one eupath database.
#' @param master  Primary keytype to use for indexing the various tables.
#' @param query_species A list of exact species names to search for.  If uncertain
#'   about them, add print_speciesnames=TRUE and be ready for a big blob of
#'   text.  If left null, then it will pull all species.
#' @param id_column What column in the database provides the set of ortholog IDs?
#' @param org_column What column provides the species name?
#' @param url_column What column provides the orthomcl group ID?
#' @param count_column Name of the column with the count of species represented.
#' @param print_speciesnames Dump the species names for diagnostics?
#' @return A big table of orthoMCL families, the columns are:
#'  \enumerate{
#'   \item  GID: The gene ID
#'   \item  ORTHOLOG_ID: The gene ID of the associated ortholog.
#'   \item  ORTHOLOG_SPECIES: The species of the associated ortholog.
#'   \item  ORTHOLOG_URL: The OrthoMCL group ID's URL.
#'   \item  ORTHOLOG_COUNT: The number of all genes from all species represented in
#'   this group.
#'   \item  ORTHOLOG_GROUP: The family ID
#'   \item  QUERIES_IN_GROUP: How many of the query species are represented in this
#'   group?
#'   \item  GROUP_REPRESENTATION: ORTHOLOG_COUNT / the number of possible species.
#'  }
#' @author atb
#' @export
extract_eupath_orthologs <- function(db, master="GID", query_species=NULL,
                                     id_column="ORTHOLOG_ID",
                                     org_column="ORGANISM",
                                     url_column="ORTHOLOG_GROUP",
                                     count_column="ORTHOLOG_COUNT",
                                     print_speciesnames=FALSE,
                                     webservice="eupathdb") {

  load_pkg <- function(name, ...) {
    metadata <- download_eupath_metadata(webservice=webservice)
    entry <- get_eupath_entry(name)
    first_name <- entry[["Species"]]
    pkg_names <- get_eupath_pkgnames(entry)
    first_pkg <- pkg_names[["orgdb"]]
    tt <- try(do.call("library", as.list(first_pkg)), silent=TRUE)
    if (class(tt) == "try-error") {
      message("Did not find the package: ",
              first_pkg,
              ". Will not be able to do reciprocal hits.")
      message("Perhaps try invoking the following: make_eupath_organismdbi('",
              first_name, "')")
      pkg <- NULL
    } else {
      message("Loaded: ", first_pkg)
      pkg <- get(first_pkg)
    }
    return(pkg)
  }  ## End internal function 'load_pkg()'

  pkg <- NULL
  if (class(db)[1] == "OrgDb") {
    pkg <- db
  } else if (class(db)[1] == "character") {
    pkg <- load_pkg(db)
  } else {
    stop("I only understand orgdbs or the name of a species.")
  }

  columns <- c(id_column, org_column, url_column, count_column)
  gene_set <- AnnotationDbi::keys(pkg, keytype=master)
  column_set <- AnnotationDbi::columns(pkg)
  column_intersect <- columns %in% column_set
  if (sum(column_intersect) == length(columns)) {
    message("Found all the required columns!")
  } else {
    missing_idx <- ! columns %in% column_set
    missing <- columns[missing_idx]
    message("Some columns were missing: ", toString(missing))
    message("Removing them, which may end badly.")
    columns <- columns[column_intersect]
  }
  all_orthos <- AnnotationDbi::select(x=pkg, keytype=master,
                                      keys=gene_set, columns=columns)
  all_orthos[["ORTHOLOG_GROUP_ID"]] <- gsub(pattern="^.*>(.*)<\\/a>$",
                                            replacement="\\1", x=all_orthos[[url_column]])
  all_orthos[[org_column]] <- as.factor(all_orthos[[org_column]])
  num_possible <- 1
  species_names <- levels(all_orthos[[org_column]])
  if (is.null(query_species)) {
    query_species <- species_names
  } else if (! query_species %in% species_names) {
    warning("Did not find the desired species in the set of all species.")
    query_species <- species_names
  }
  num_possible <- length(species_names)
  message("There are ", num_possible, " possible species in this group.")

  if (isTRUE(print_speciesnames)) {
    print(toString(species_names))
    return(invisible())
  }

  ## Now pull out the species of interest
  found_species <- 0
  for (sp in query_species) {
    if (sp %in% all_orthos[[org_column]]) {
      message("Found species: ", sp)
    } else {
      message("Did not find species: ", sp)
    }
  }
  kept_orthos_idx <- all_orthos[[org_column]] %in% query_species
  kept_orthos <- all_orthos[kept_orthos_idx, ]
  colnames(kept_orthos) <- c(master, "ORTHOLOG_ID", "ORTHOLOG_SPECIES",
                             "ORTHOLOG_URL", "ORTHOLOG_COUNT", "ORTHOLOG_GROUP")
  kept_orthos[["ORTHOLOG_COUNT"]] <- as.integer(kept_orthos[["ORTHOLOG_COUNT"]])

  kept_orthos_dt <- data.table::as.data.table(kept_orthos) %>%
    dplyr::group_by_(master) %>%
    dplyr::add_count_(master)
  colnames(kept_orthos_dt) <- c(master, "ORTHOLOG_ID", "ORTHOLOG_SPECIES",
                             "ORTHOLOG_URL", "ORTHOLOG_COUNT", "ORTHOLOG_GROUP",
                             "QUERIES_IN_GROUP")

  kept_orthos_dt[["GROUP_REPRESENTATION"]] <- kept_orthos_dt[["ORTHOLOG_COUNT"]] / num_possible
  num_queries <- length(query_species)

  return(kept_orthos_dt)
}

#' Clean up the gene location field from eupathdb derived gene location data.
#'
#' The eupathdb encodes its location data for genes in a somewhat peculiar
#' format: chromosome:start..end(strand), but I would prefer to have these
#' snippets of information as separate columns so that I can do things like
#' trivially perform rpkm().
#'
#' @param annot_df Data frame resulting from load_orgdb_annotations()
#' @param location_column Name of the column to extract the start/end/length/etc from.
#' @return Somewhat nicer data frame.
#' @author atb
#' @export
extract_gene_locations <- function(annot_df, location_column="annot_gene_location_text") {
  newdf <- annot_df %>%
    tidyr::separate(location_column,
                    c("chromosome", "location"), ":")
  newdf <- newdf %>%
    tidyr::separate("location", c("start", "end"), "\\.\\.")
  newdf[["start"]] <- as.numeric(gsub(pattern="\\,", replacement="", x=newdf[["start"]]))
  newdf <- newdf %>%
    tidyr::separate("end", c("end", "strand"), "\\(")
  newdf[["end"]] <- as.numeric(gsub(pattern="\\,", replacement="", x=newdf[["end"]]))
  newdf[["strand"]] <- as.factor(gsub(pattern="\\)", replacement="", x=newdf[["strand"]]))
  newdf[["length"]] <- abs(newdf[["start"]] - newdf[["end"]])
  return(newdf)
}

#' Generate a BSgenome package from the eupathdb.
#'
#' Since we go to the trouble to try and generate nice orgdb/txdb/organismdbi
#' packages, it seems to me that we ought to also be able to make a readable
#' genome package.  I should probably use some of the logic from this to make
#' the organismdbi generator smarter.
#'
#' @param entry  Single eupathdb metadata entry.
#' @param version Which version of the eupathdb to use for creating the BSGenome?
#' @param dir  Working directory.
#' @param reinstall  Rewrite an existing package directory.
#' @param ... Extra arguments for downloading metadata when not provided.
#' @return  List of package names generated (only 1).
#' @author atb
#' @export
make_eupath_bsgenome <- function(entry, version=NULL, dir="eupathdb",
                                 reinstall=FALSE, ...) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  species <- entry[["Species"]]
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["bsgenome"]]
  if (pkgname %in% installed.packages() & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "bsgenome_name" = pkgname
    )
    return(retlist)
  }

  ## Figure out the version numbers and download urls.
  db_version <- entry[["SourceVersion"]]
  if (!is.null(version)) {
    db_version <- version
  }
  fasta_start <- entry[["SourceUrl"]]
  fasta_starturl <- sub(pattern="gff",
                        replacement="fasta",
                        x=fasta_start,
                        perl=TRUE)
  fasta_url <- sub(pattern="\\.gff", replacement="_Genome\\.fasta",
                   x=fasta_starturl)
  fasta_hostname <- sub(pattern="https://(.*)\\.org.*$",
                        replacement="\\1",
                        x=fasta_start)
  ## genome_filename <- file.path(dir, paste0(pkgname, ".fasta"))
  genome_filename <- file.path(dir, glue::glue("{pkgname}.fasta"))

  ## Find a spot to dump the fasta files
  bsgenome_base <- file.path(dir)
  bsgenome_dir <- file.path(bsgenome_base, pkgname)
  if (!file.exists(bsgenome_dir)) {
    created <- dir.create(bsgenome_dir, recursive=TRUE)
  }
  ## Download them to this directory.
  downloaded <- download.file(url=fasta_url, destfile=genome_filename, quiet=FALSE)
  ## And extract all the individual chromosomes into this directory.
  input <- Biostrings::readDNAStringSet(genome_filename)
  output_list <- list()
  sequence_names <- "c("
  message("Writing chromosome files, this is slow for fragmented scaffolds.")
  show_progress <- interactive() && is.null(getOption("knitr.in.progress"))
  if (isTRUE(show_progress)) {
    bar <- utils::txtProgressBar(style=3)
  }
  for (index in 1:length(input)) {
    if (isTRUE(show_progress)) {
      pct_done <- index / length(input)
      setTxtProgressBar(bar, pct_done)
    }
    chr <- names(input)[index]
    chr_name <- strsplit(chr, split=" ")[[1]][1]
    ## chr_file <- file.path(bsgenome_dir, paste0(chr_name, ".fa"))
    chr_file <- file.path(bsgenome_dir, glue::glue("{chr_name}.fa"))
    output <- Biostrings::writeXStringSet(input[index], chr_file, append=FALSE,
                                          compress=FALSE, format="fasta")
    output_list[[chr_name]] <- chr_file
    sequence_names <- paste0(sequence_names, '"', chr_name, '", ')
  }
  if (isTRUE(show_progress)) {
    close(bar)
  }
  sequence_names <- gsub(pattern=", $", replacement=")", x=sequence_names)

  ## Now start creating the DESCRIPTION file
  desc_file <- file.path(bsgenome_dir, "DESCRIPTION")
  descript <- desc::description$new("!new")
  descript$set(Package=pkgname)
  author <- "Ashton Trey Belew <abelew@umd.edu>"
  ## title <- paste0(taxa[["genus"]], " ", taxa[["species"]], " strain ", taxa[["strain"]],
  ##                 " version ", db_version)
  title <- glue::glue("{taxa[['genus']]} {taxa[['species']]} strain {taxa[['strain']]} \\
                version {db_version}")

  descript$set(Title=title)
  descript$set(Author=author)
  version_string <- format(Sys.time(), "%Y.%m")
  descript$set(Version=version_string)
  descript$set(Maintainer=author)
  descript$set(Description=glue::glue("A full genome from the eupathdb for {title}."))
  descript$set(License="Artistic-2.0")
  descript$set(URL="https://eupathdb.org")
  descript$set(BugReports="https://github.com/elsayed-lab")
  descript$set(seqs_srcdir=bsgenome_dir)
  descript$set(seqnames=sequence_names)
  descript$set(organism=taxa[["taxon"]])
  descript$set(common_name=taxa[["genus_species"]])
  descript$set(provider=fasta_hostname)
  descript$set(provider_version=glue::glue("{fasta_hostname} {db_version}"))
  descript$set(release_date=format(Sys.time(), "%Y%m%d"))
  descript$set(BSgenomeObjname=glue::glue("{taxa[['genus_species']]}_{taxa[['strain']]}"))
  descript$set(release_name=db_version)
  descript$set(organism_biocview=glue::glue("{taxa[['genus_species']]}_{taxa[['strain']]}"))
  descript$del("LazyData")
  descript$del("Authors@R")
  descript$del("URL")
  descript$del("BugReports")
  descript$del("Encoding")
  description_file <- file.path(bsgenome_dir, "DESCRIPTION")
  descript$write(description_file)

  ## Generate the package, this puts it into the cwd.
  message("Starting forgeBSgenomeDataPkg().")
  tt <- requireNamespace("Biostrings")
  ## Otherwise I get error in cannot find uniqueLetters (this seems to be a new development)
  library(Biostrings)
  annoying <- try(BSgenome::forgeBSgenomeDataPkg(description_file))

  if (class(annoying) != "try-error") {
    inst <- try(devtools::install(pkgname, quiet=TRUE))
  }

  retlist <- list()
  if (class(inst) != "try-error") {
    retlist[["bsgenome_name"]] <- pkgname
    ## Clean up a little.
    deleted <- unlink(x=bsgenome_dir, recursive=TRUE, force=TRUE)
    built <- try(devtools::build(pkgname, quiet=TRUE))
    if (class(built) != "try-error") {
      moved <- file.rename(glue::glue("{pkgname}_{version_string}.tar.gz"),
                           glue::glue("{bsgenome_dir}_{version_string}.tar.gz"))
      final_deleted <- unlink(x=pkgname, recursive=TRUE, force=TRUE)
    }
  } else {
    retlist <- inst
  }
  return(retlist)
}

#' Search the eupathdb metadata for a given species substring.
#'
#' When querying the eupathdb, it can be difficult to hit the desired species.
#' This is confounded by the fact that there are very similar named species
#' across different EupathDB projects.  Thus function seeks to make it a bit
#' easier to find the actual dataset desired.  If the specific species is not
#' found, look for a reasonably approximation. stop() if nothing is found.
#'
#' @param species String containing some reasonably unique text in the desired
#'   species name.
#' @param webservice The EuPathDB webservice to query.
#' @return  A single row from the eupathdb metadata.
#' @author atb
#' @export
get_eupath_entry <- function(species="Leishmania major", webservice="eupathdb") {
  metadata <- download_eupath_metadata(webservice=webservice)
  all_species <- metadata[["Species"]]
  entry <- NULL
  grep_hits <- grepl(species, all_species)
  grepped_hits <- all_species[grep_hits]
  if (species %in% all_species) {
    entry <- metadata[metadata[["Species"]] == species, ]
    message("Found: ", entry[["Species"]])
  } else if (sum(grep_hits >= 1)) {
    species <- grepped_hits[[1]]
    entry <- metadata[metadata[["Species"]] == species, ]
    if (sum(grep_hits > 1)) {
      message("Found the following hits: ", toString(grepped_hits), ", choosing the first.")
    }
  } else {
    message("Here are the possible species: ", toString(all_species))
    stop("Did not find your species.")
  }
  return(entry)
}

#' Generate standardized package names for the various eupathdb species.
#'
#' This is a surprisingly difficult problem.  Many species names in the eupathdb
#' have odd characters in the species suffix which defines the strain ID.  Many
#' of these peculiarities result in packages which are non-viable for
#' installation.  Thus this function attempts to filter them out and result in
#' consistent, valid package names.  They are not exactly the same in format as
#' other orgdb/txdb/etc packages, as I include in them a field for the eupathdb
#' version used; but otherwise they should be familiar to any user of the sqlite
#' based organism packages.
#'
#' The default argument for this function shows the funniest one I have found so
#' far thanks to the hash character in the strain definition.
#'
#' @param species  Species names taken from a metadata instance from a eupath project.
#' @param version  Choose a specific version of the eupathdb, only really useful
#'   when downloading files.
#' @param metadata  Eupathdb metadata.
#' @param ...  Further arguments to pass to download_eupath_metadata()
#' @return  List of package names and some booleans to see if they have already
#'   been installed.
#' @author atb
#' @export
get_eupath_pkgnames <- function(entry, version=NULL) {
  species <- entry[["Species"]]
  version_string <- glue::glue(".v{entry[['SourceVersion']]}")
  if (!is.null(version)) {
    version_string <- glue::glue(".v{version}")
  }

  taxa <- make_taxon_names(entry)
  first_char <- strsplit(taxa[["genus"]], split="")[[1]][[1]]
  pkg_list <- list(
    "bsgenome" = glue::glue("BSGenome.{taxa[['taxon']]}{version_string}"),
    "bsgenome_installed" = FALSE,
    ## "organismdbi" = paste0("eupathdb.", taxa[["taxon"]], version_string),
    "organismdbi" = glue::glue("eupathdb.{taxa[['taxon']]}{version_string}"),
    "organismdbi_installed" = FALSE,
    "orgdb" = glue::glue("org.{first_char}{taxa[['species_strain']]}{version_string}.eg.db"),
    "orgdb_installed" = FALSE,
    "txdb" = glue::glue("TxDb.{taxa[['genus']]}.{taxa[['species_strain']]}.\\
                  {entry[['DataProvider']]}{version_string}"),
    "txdb_installed" = FALSE
  )

  inst <- as.data.frame(installed.packages())
  if (pkg_list[["bsgenome"]] %in% inst[["Package"]]) {
    pkg_list[["bsgenome_installed"]] <- TRUE
  }
  if (pkg_list[["organismdbi"]] %in% inst[["Package"]]) {
    pkg_list[["organismdbi_installed"]] <- TRUE
  }
  if (pkg_list[["orgdb"]] %in% inst[["Package"]]) {
    pkg_list[["orgdb_installed"]] <- TRUE
  }
  if (pkg_list[["txdb"]] %in% inst[["Package"]]) {
    pkg_list[["txdb_installed"]] <- TRUE
  }

  return(pkg_list)
}

#' Shortcut for loading annotation data from a eupathdb-based orgdb.
#'
#' Every time I go to load the annotation data from an orgdb for a parasite, it
#' takes me an annoyingly long time to get the darn flags right.  As a result I
#' wrote this to shortcut that process.  Ideally, one should only need to pass
#' it a species name and get out a nice big table of annotation data.
#'
#' @param species  String containing a unique portion of the desired species.
#' @param webservice Which eupath webservice is desired?
#' @param version Gather data from a specific eupathdb version?
#' @param wanted_fields If not provided, this will gather all columns starting
#'   with 'annot'.
#' @return Big huge data frame of annotation data.
#' @export
load_eupath_annotations <- function(species="Leishmania major", webservice="tritrypdb",
                                    version=NULL, wanted_fields=NULL) {
  metadata <- download_eupath_metadata(webservice=webservice)
  pkg_names <- get_eupath_pkgnames(species=species, metadata=metadata, version=version)
  pkg_installedp <- pkg_names[["orgdb_installed"]]
  if (isFALSE(pkg_installedp)) {
    stop("The required package is not installed.")
  }
  pkg <- as.character(pkg_names[["orgdb"]])

  if (is.null(wanted_fields)) {
    org_pkgstring <- glue("library({pkg}); pkg <- {pkg}")
    eval(parse(text=org_pkgstring))
    all_fields <- AnnotationDbi::keytypes(x=pkg)
    annot_fields_idx <- grepl(pattern="^ANNOT", x=all_fields)
    annot_fields <- all_fields[annot_fields_idx]
    wanted_fields <- c("gid", annot_fields)
  }
  org <- load_orgdb_annotations(pkg, keytype="gid", fields=wanted_fields)[["genes"]]
  colnames(org) <- gsub(pattern="^annot_", replacement="", x=colnames(org))
  kept_columns <- !duplicated(colnames(org))
  org <- org[, kept_columns]
  return(org)
}

#' Create an organismDbi instance for an eupathdb organism.
#'
#' The primary goal of an organismdbi instance is to provide a series of links
#' between an orgdb, txdb, and other relevant annotation packages
#' (reactome/go/etc).  In its current iteration, this function brings together a
#' couple columns from the orgdb, txdb, GO.db, and reactome.db.
#'
#' @param species  A species in the eupathDb metadata.
#' @param entry  A row from the eupathdb metadataframe.
#' @param version  Which version of the eupathdb to use for creating this package?
#' @param dir  Directory in which to build the packages.
#' @param reinstall  Overwrite existing data files?
#' @param kegg_abbreviation  For when we cannot automagically find the kegg species id.
#' @param exclude_join  I had a harebrained idea to automatically set up the
#'   joins between columns of GO.db/reactome.db/orgdb/txdb objects.  This
#'   variable is intended to exclude columns with common IDs that might
#'   multi-match spuriously -- I think in the end I killed the idea though,
#'   perhaps this should be removed or resurrected.
#' @return  The result of attempting to install the organismDbi package.
#' @author  Keith Hughitt, modified by atb.
#' @export
make_eupath_organismdbi <- function(entry=NULL, version=NULL, dir="eupathdb", reinstall=FALSE,
                                    kegg_abbreviation=NULL, exclude_join="ENTREZID",
                                    webservice="eupathdb") {
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["organismdbi"]]
  if (isTRUE(pkgnames[["organismdbi_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    return(pkgnames)
  }
  orgdb_name <- pkgnames[["orgdb"]]
  txdb_name <- pkgnames[["txdb"]]
  orgdb_ret <- make_eupath_orgdb(entry, version=version, dir=dir,
                                 kegg_abbreviation=kegg_abbreviation, reinstall=reinstall)
  if (is.null(orgdb_ret)) {
    return(NULL)
  }
  txdb_ret <- make_eupath_txdb(entry, version=version, dir=dir, reinstall=reinstall)
  if (is.null(txdb_ret)) {
    return(NULL)
  }

  tt <- requireNamespace(orgdb_name)
  tt <- requireNamespace(txdb_name)
  test <- do.call("library", as.list(orgdb_name))
  test <- do.call("library", as.list(txdb_name))
  organism <- taxa[["taxon"]]
  required <- requireNamespace("OrganismDbi")

  message("Joining the txdb and orgdb objects.")
  count <- 0
  graph_data <- list()
  geneids_found <- "GID" %in% AnnotationDbi::keytypes(get(orgdb_name)) &&
    "GENEID" %in% AnnotationDbi::keytypes(get(txdb_name))
  if (isTRUE(geneids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(orgdb="GID",  txdb="GENEID")
    names(graph_data[[name]]) <- c(orgdb_name, txdb_name)
  }
  required <- requireNamespace("GO.db")
  required <- try(attachNamespace("GO.db"), silent=TRUE)
  ## FIXME Theoretically we should no longer have columns with names like
  ## GO_GO
  orgdb_go_col <- "GO_GO_ID"
  goids_found <- "GOID" %in% AnnotationDbi::keytypes(get("GO.db")) &&
    orgdb_go_col %in% AnnotationDbi::keytypes(get(orgdb_name))
  if (isTRUE(goids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(GO.db="GOID", orgdb=orgdb_go_col)
    names(graph_data[[name]]) <- c("GO.db", orgdb_name)
  }
  ## FIXME Theoretically we should no longer have columns with names like
  ## PATHWAY_PATHWAY
  required <- requireNamespace("reactome.db")
  required <- try(attachNamespace("reactome.db"), silent=TRUE)
  orgdb_path_col <- "PATHWAY_PATHWAY"
  reactomeids_found <- "REACTOMEID" %in% AnnotationDbi::keytypes(get("reactome.db")) &&
    orgdb_path_col %in% AnnotationDbi::keytypes(get(orgdb_name))
  if (isTRUE(reactomeids_found)) {
    count <- count + 1
    name <- glue::glue("join{count}")
    graph_data[[name]] <- c(reactome.db="REACTOMEID", orgdb=orgdb_path_col)
    names(graph_data[[name]]) <- c("reactome.db", orgdb_name)
  }

  author <- as.character(entry[["Maintainer"]])
  maintainer <- as.character(entry[["Maintainer"]])
  final_dir <- file.path(dir, pkgname)
  if (file.exists(final_dir)) {
    if (isTRUE(reinstall)) {
      unlinkret <- unlink(x=final_dir, recursive=TRUE)
    } else {
      if (file.exists(glue::glue("{final_dir}.bak"))) {
        unlinkret <- unlink(x=glue::glue("{final_dir}.bak"), recursive=TRUE)
      }
      renamed <- file.rename(from=final_dir, to=glue::glue("{final_dir}.bak"))
    }
  }

  tmp_pkg_dir <- file.path(dir)
  if (!file.exists(tmp_pkg_dir)) {
    dir.create(tmp_pkg_dir, recursive=TRUE)
  }
  version_string <- format(Sys.time(), "%Y.%m")
  organdb <- OrganismDbi::makeOrganismPackage(
                            pkgname=pkgname,
                            graphData=graph_data,
                            organism=organism,
                            version=version_string,
                            maintainer=maintainer,
                            author=author,
                            destDir=tmp_pkg_dir,
                            license="Artistic-2.0")
  organdb_path <- clean_pkg(final_dir)
  organdb_path <- clean_pkg(organdb_path, removal="_", replace="", sqlite=FALSE)
  organdb_path <- clean_pkg(organdb_path, removal="_like", replace="like", sqlite=FALSE)
  if (class(organdb) == "list") {
    inst <- try(devtools::install(organdb_path))
    if (class(inst) != "try-error") {
      built <- try(devtools::build(organdb_path, quiet=TRUE))
      if (class(built) != "try-error") {
        final_deleted <- unlink(x=organdb_path, recursive=TRUE, force=TRUE)
      }
    }
  }
  final_organdb_name <- basename(organdb_path)
  retlist <- list(
    "orgdb_name" = orgdb_name,
    "txdb_name" = txdb_name,
    "organdb_name" = final_organdb_name
  )
  return(retlist)
}

#' Create an orgdb SQLite database from the tables in eupathdb.
#'
#' This function has passed through multiple iterations as the preferred
#' method(s) for accessing data in the eupathdb has changed.  It currently uses
#' my empirically defined set of queries against the eupathdb webservices.  As a
#' result, I have made some admittedly bizarre choices when creating the
#' queries.  Check through eupath_webservices.r for some amusing examples of how
#' I have gotten around the idiosyncrasies in the eupathdb.
#'
#' @param species  A specific species ID to query
#' @param entry  If not provided, then species will get this, it contains all the information.
#' @param dir  Where to put all the various temporary files.
#' @param version  Which version of the eupathdb to use for creating this package?
#' @param kegg_abbreviation  If known, provide the kegg abbreviation.
#' @param reinstall  Re-install an already existing orgdb?
#' @param ...  Extra parameters when searching for metadata
#' @return  Currently only the name of the installed package.  This should
#'   probably change.
#' @author Keith Hughitt with significant modifications by atb.
#' @export
make_eupath_orgdb <- function(entry=NULL, dir="eupathdb", version=NULL,
                              kegg_abbreviation=NULL, reinstall=FALSE,
                              do_kegg=TRUE, ...) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }
  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["orgdb"]]
  if (isTRUE(pkgnames[["orgdb_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "orgdb_name" = pkgname
    )
    return(retlist)
  }

  if (!file.exists(dir)) {
    created <- dir.create(dir, recursive=TRUE)
  }

  if (is.null(kegg_abbreviation)) {
    kegg_abbreviation <- get_kegg_orgn(glue::glue("{taxa[['genus']]} {taxa[['species']]}"))
    if (length(kegg_abbreviation) == 0) {
      do_kegg <- FALSE
    }
  }

  chosen_provider <- entry[["DataProvider"]]
  chosen_species <- entry[["Species"]]

  gene_table <- try(post_eupath_annotations(entry, dir=dir))
  if (class(gene_table) == "try-error") {
    gene_table <- data.frame()
  }

  go_table <- try(post_eupath_go_table(entry, dir=dir))
  if (class(go_table) == "try-error") {
    go_table <- data.frame()
  }

  gene_ids <- gene_table[["GID"]]
  ortholog_table <- try(get_orthologs_all_genes(entry=entry, dir=dir, gene_ids=gene_ids))
  ##ortholog_table <- try(post_eupath_ortholog_table(species=chosen_species, entry=entry, dir=dir))
  if (class(ortholog_table) == "try-error") {
    ortholog_table <- data.frame()
  }

  interpro_table <- try(post_eupath_interpro_table(entry=entry,
                                                   webservice=webservice, dir=dir))
  if (class(interpro_table) == "try-error") {
    interpro_table <- data.frame()
  }

  pathway_table <- try(post_eupath_pathway_table(entry=entry, dir=dir))
  if (class(pathway_table) == "try-error") {
    pathway_table <- data.frame()
  }

  kegg_table <- try(load_kegg_annotations(species=taxa[["genus_species"]],
                                          flatten=FALSE, abbreviation=kegg_abbreviation))
  if (class(kegg_table) == "try-error") {
    kegg_table <- data.frame()
  } else {
    colnames(kegg_table) <- glue::glue("KEGGREST_{toupper(colnames(kegg_table))}")
    colnames(kegg_table)[[1]] <- "GID"
  }

  if (nrow(gene_table) == 0) {
    warning("Unable to create an orgdb for this species.")
    return(NULL)
  }

  chromosome_table <- gene_table[, c("GID", "ANNOT_SEQUENCE_ID")]
  colnames(chromosome_table) <- c("GID", "CHR_ID")
  type_table <- gene_table[, c("GID", "ANNOT_GENE_TYPE")]
  colnames(type_table) <- c("GID", "GENE_TYPE")

  ## Compile list of arguments for makeOrgPackage call
  version_string <- format(Sys.time(), "%Y.%m")
  orgdb_args <- list(
    "gene_info" = gene_table,
    "chromosome" = chromosome_table,
    "type" = type_table,
    "version" = version_string,
    "author" = entry[["Maintainer"]],
    "maintainer" = entry[["Maintainer"]],
    "tax_id" = as.character(entry[["TaxonomyId"]]),
    "genus" = taxa[["genus"]],
    "species" = glue::glue("{taxa[['species_strain']]}.v{entry[['SourceVersion']]}"),
    "outputDir" = dir)

  ## add non-empty tables
  if (is.null(go_table)) {
    message("This should not be possible, but the go table is still null.")
  } else if (nrow(go_table) > 0) {
    orgdb_args[["go"]] <- go_table
  }
  if (is.null(ortholog_table)) {
    message("This should not be possible, but the ortholog table is still null.")
  } else if (nrow(ortholog_table) > 0) {
    orgdb_args[["orthologs"]] <- ortholog_table
  }
  if (is.null(interpro_table)) {
    message("This should not be possible, but the interpro table is still null.")
  } else if (nrow(interpro_table) > 0) {
    orgdb_args[["interpro"]] <- interpro_table
  }
  if (is.null(pathway_table)) {
    message("This should not be possible, but the pathway table is still null.")
  } else if (nrow(pathway_table) > 0) {
    orgdb_args[["pathway"]] <- pathway_table
  }
  if (is.null(kegg_table)) {
    message("This should not be possible, but the kegg table is still null.")
  } else if (nrow(kegg_table) > 0) {
    orgdb_args[["kegg"]] <- kegg_table
  }

  ## Make sure no duplicated stuff snuck through, or makeOrgPackage throws an error.
  ## Make sure that every GID field is character, too
  ## -- otherwise you get 'The type of data in the 'GID'
  ## columns must be the same for all data.frames.'
  used_columns <- c()
  for (i in 1:length(orgdb_args)) {
    argname <- names(orgdb_args)[i]
    if (class(orgdb_args[[i]])[1] == "data.frame") {
      ## Make sure that the column names in this data frame are unique.
      ## This starts at 2 because the first column should _always_ by 'GID'
      for (cn in 2:length(colnames(orgdb_args[[i]]))) {
        colname <- colnames(orgdb_args[[i]])[cn]
        if (colname %in% used_columns) {
          new_colname <- glue::glue("{toupper(argname)}_{colname}")
          colnames(orgdb_args[[i]])[cn] <- new_colname
          used_columns <- c(used_columns, new_colname)
        } else {
          used_columns <- c(used_columns, colname)
        }
      }
      ## First swap out NA to ""
      na_tmp <- orgdb_args[[i]]
      na_set <- is.na(na_tmp)
      na_tmp[na_set] <- ""
      orgdb_args[[i]] <- na_tmp
      ## Then remove duplicated elements.
      orgdb_dups <- duplicated(orgdb_args[[i]])
      if (sum(orgdb_dups) > 0) {
        tmp <- orgdb_args[[i]]
        tmp <- tmp[!orgdb_dups, ]
        orgdb_args[[i]] <- tmp
      }
      ## Finally, make sure all GID columns are characters
      orgdb_args[[i]][["GID"]] <- as.character(orgdb_args[[i]][["GID"]])
    } ## End checking for data.frames
  }

  ## The following lines are because makeOrgPackage fails stupidly if the directory exists.
  backup_path <- file.path(dir, glue::glue("{pkgname}.bak"))
  first_path <- file.path(dir, pkgname)
  if (file.exists(backup_path)) {
    message(backup_path, " already exists, deleting it.")
    ret <- unlink(backup_path, recursive=TRUE)
  }
  if (file.exists(first_path)) {
    message(first_path, " already exists, backing it up.")
    ret <- file.rename(first_path, backup_path)
  }

  lib_result <- requireNamespace("AnnotationForge")
  att_result <- try(attachNamespace("AnnotationForge"), silent=TRUE)
  message(sprintf("- Calling makeOrgPackage for %s", entry[["Species"]]))
  orgdb_path <- try(do.call("makeOrgPackage", orgdb_args))
  if (class(orgdb_path) == "try-error") {
    return(NULL)
  }

  ## Fix name in sqlite metadata table
  dbpath <- file.path(
    orgdb_path, "inst/extdata", sub(".db", ".sqlite", basename(orgdb_path)))
  message(sprintf("- Fixing sqlite Orgdb sqlite database %s", dbpath))

  ## make sqlite database editable
  Sys.chmod(dbpath, mode="0644")
  db <- RSQLite::dbConnect(RSQLite::SQLite(), dbname=dbpath)
  ## update SPECIES field
  query <- sprintf('UPDATE metadata SET value="%s" WHERE name="SPECIES";', entry[["Species"]])
  sq_result <- RSQLite::dbSendQuery(conn=db, query)
  ## update ORGANISM field
  query <- sprintf('UPDATE metadata SET value="%s" WHERE name="ORGANISM";', entry[["Species"]])
  sq_result <- RSQLite::dbSendQuery(conn=db, query)
  ## lock it back down
  Sys.chmod(dbpath, mode="0444")

  ## Clean up any strangeness in the DESCRIPTION file
  orgdb_path <- clean_pkg(orgdb_path)
  orgdb_path <- clean_pkg(orgdb_path, removal="_", replace="")
  orgdb_path <- clean_pkg(orgdb_path, removal="_like", replace="like")
  testthat::expect_equal(first_path, orgdb_path)
  ## And install the resulting package.
  inst <- try(devtools::install(orgdb_path, quiet=TRUE))
  if (class(inst) != "try-error") {
    built <- try(devtools::build(orgdb_path, quiet=TRUE))
    if (class(built) != "try-error") {
      final_deleted <- unlink(x=orgdb_path, recursive=TRUE, force=TRUE)
    }
  }

  ## Probably should return something more useful/interesting than this, perhaps
  ## the dimensions of the various tables in the orgdb?
  ## return the path to the sqlite database
  retlist <- list(
    "orgdb_name" = pkgname
  )
  return(retlist)
}

#' Generate TxDb for EuPathDB organism
#'
#' @param species  Species name from the eupathdb metadata.
#' @param entry  One row from the organism metadata.
#' @param version  Which version of the eupathdb to use for creating this package?
#' @param dir  Base directory for building the package.
#' @param reinstall  Overwrite an existing installed package?
#' @param ...  Extra arguments for getting metadata.
#' @return TxDb instance name.
#' @author Keith Hughitt with significant modifications by atb.
#' @export
make_eupath_txdb <- function(entry=NULL, dir="eupathdb", version=NULL, reinstall=FALSE, ...) {
  if (is.null(entry)) {
    stop("Need an entry.")
  }

  taxa <- make_taxon_names(entry)
  pkgnames <- get_eupath_pkgnames(entry, version=version)
  pkgname <- pkgnames[["txdb"]]

  if (isTRUE(pkgnames[["txdb_installed"]]) & !isTRUE(reinstall)) {
    message(pkgname, " is already installed, set reinstall=TRUE if you wish to reinstall.")
    retlist <- list(
      "txdb_name" = pkgname
    )
    return(retlist)
  }

  ## save gff as tempfile
  input_gff <- file.path(dir, glue::glue("{pkgname}.gff"))
  tt <- download.file(url=entry[["SourceUrl"]], destfile=input_gff,
                         method="internal", quiet=FALSE)

  chr_entries <- read.delim(file=input_gff, header=FALSE, sep="")
  chromosomes <- chr_entries[["V1"]] == "##sequence-region"
  chromosomes <- chr_entries[chromosomes, c("V2", "V3", "V4")]
  colnames(chromosomes) <- c("ID", "start", "end")
  chromosome_info <- data.frame(
    "chrom" = chromosomes[["ID"]],
    "length" = as.numeric(chromosomes[["end"]]),
    "is_circular" = NA,
    stringsAsFactors=FALSE)

  txdb_metadata <- as.data.frame(t(entry))
  txdb_metadata[["name"]] <- rownames(txdb_metadata)
  colnames(txdb_metadata) <- c("value", "name")
  txdb_metadata <- txdb_metadata[, c("name", "value")]
  txdb <- try(GenomicFeatures::makeTxDbFromGFF(
                                    file=input_gff,
                                    format="gff",
                                    chrominfo=chromosome_info,
                                    dataSource=entry[["SourceUrl"]],
                                    organism=glue::glue("{taxa[['genus']]} {taxa[['species']]}"),
                                    ## metadata=t(entry))
                                    ))
  if (class(txdb) == "try-error") {
    message("The txdb creation failed.")
    return(NULL)
  }

  ## This is the section I yanked
  provider <- getMetaDataValue(txdb, "Data source")
  providerVersion <- getTxDbVersion(txdb)
  dbType <- getMetaDataValue(txdb, "Db type")
  authors <- normAuthor(entry[["Maintainer"]], entry[["Maintainer"]])
  template_path <- system.file("txdb-template", package="GenomicFeatures")
  version_string <- format(Sys.time(), "%Y.%m")
  data_source <- getMetaDataValue(txdb, "Data source")
  symvals <- list(
    "PKGTITLE" = glue::glue("Annotation package for {dbType} object(s)"),
    "PKGDESCRIPTION" = glue::glue("Exposes an annotation databases generated from \\
                             {data_source} by exposing these as {dbType} objects"),
    "PKGVERSION" = version_string,
    "AUTHOR" = paste(authors, collapse = ", "),
    "MAINTAINER" = as.character(getMaintainer(authors)),
    "GFVERSION" = getMetaDataValue(txdb,
                                   "GenomicFeatures version at creation time"),
    "LIC" = "Artistic-2.0",
    "DBTYPE" = dbType,
    "ORGANISM" = getMetaDataValue(txdb, "Organism"),
    "SPECIES" = getMetaDataValue(txdb, "Organism"),
    "PROVIDER" = provider,
    "PROVIDERVERSION" = providerVersion,
    "RELEASEDATE" = getMetaDataValue(txdb, "Creation time"),
    ## SOURCEURL = getMetaDataValue(txdb, "Resource URL"),
    "SOURCEURL" = entry[["SourceUrl"]],
    "ORGANISMBIOCVIEW" = gsub(" ", "_", getMetaDataValue(txdb, "Organism")),
    "TXDBOBJNAME" = pkgname)
  if (any(duplicated(names(symvals)))) {
    str(symvals)
    stop("'symvals' contains duplicated symbols")
  }
  is_OK <- sapply(symvals, S4Vectors::isSingleString)
  if (!all(is_OK)) {
    bad_syms <- paste(names(is_OK)[!is_OK], collapse=", ")
    stop("values for symbols ", bad_syms, " are not single strings")
  }
  if (!file.exists(dir)) {
    tt <- dir.create(dir, recursive=TRUE)
  }

  pkg_list <- Biobase::createPackage(pkgname=pkgname, destinationDir=dir,
                                     originDir=template_path, symbolValues=symvals,
                                     unlink=TRUE)
  db_dir <- file.path(dir, pkgname, "inst", "extdata")
  if (!file.exists(db_dir)) {
    tt <- dir.create(db_dir, recursive=TRUE)
  }
  db_path <- file.path(db_dir, paste(pkgname, "sqlite", sep="."))

  obj <- try(AnnotationDbi::saveDb(txdb, file=db_path))
  if (class(obj) == "try-error") {
    warning("Failed to save the txdb object.")
  }

  install_dir <- file.path(dir, pkgname)
  install_dir <- clean_pkg(install_dir)
  install_dir <- clean_pkg(install_dir, removal="_", replace="")
  install_dir <- clean_pkg(install_dir, removal="_like", replace="like")

  inst <- try(devtools::install(install_dir, quiet=TRUE))
  if (class(inst) != "try-error") {
    built <- try(devtools::build(install_dir, quiet=TRUE))
    if (class(built) != "try-error") {
      final_deleted <- unlink(x=install_dir, recursive=TRUE, force=TRUE)
    }
  }

  retlist <- list(
    "object" = txdb,
    "gff" = input_gff,
    "txdb_name" = pkgname)
  return(retlist)
}

#' Iterate through the various ways of representing taxon names
#'
#' Spend some time making sure they are valid, too.  Thus we want to get rid of
#' weird characters like hash marks, pipes, etc.
#'
#' @param entry  An entry of the eupathdb metadata.
#' @return  A list of hopefully valid nomenclature names to be used elsewhere in
#'   this family.
#' @author atb
make_taxon_names <- function(entry) {
  taxon <- entry[["Species"]]
  species_parts <- unlist(strsplit(taxon, " "))
  genus <- species_parts[1]
  first <- toupper(substring(genus, 1, 1))
  species <- species_parts[2]
  strain <- ""
  if (length(species_parts) >= 3) {
    for (part in 3:length(species_parts)) {
      strain <- glue::glue("{strain}.{species_parts[part]}")
    }
  }
  strain <- gsub(pattern="^\\.", replacement="", x=strain)

  ## Start by getting rid of annoying text
  strain_pattern <- "(_| |\\.)strain(_| |\\.)"
  taxon <- gsub(pattern=strain_pattern, replacement="\\1", x=taxon)
  genus <- gsub(pattern=strain_pattern, replacement="\\1", x=genus)
  species <- gsub(pattern=strain_pattern, replacement="\\1", x=species)
  strain <- gsub(pattern=strain_pattern, replacement="\\1", x=strain)

  ## Replace some annoying characters with a '.'
  annoying_pattern <- "(_|-|#| )"
  taxon <- gsub(pattern=annoying_pattern, replacement="\\.", x=taxon)
  genus <- gsub(pattern=annoying_pattern, replacement="\\.", x=genus)
  species <- gsub(pattern=annoying_pattern, replacement="\\.", x=species)
  strain <- gsub(pattern=annoying_pattern, replacement="\\.", x=strain)

  ## Completely remove the truly stupid characters.
  stupid_pattern <- "(\\,|\\/|\\?|\\|\\[|\\])"
  taxon <- gsub(pattern=stupid_pattern, replacement="", x=taxon)
  genus <- gsub(pattern=stupid_pattern, replacement="", x=genus)
  species <- gsub(pattern=stupid_pattern, replacement="", x=species)
  strain <- gsub(pattern=stupid_pattern, replacement="", x=strain)

  ## There are a few extra-weirdos with double-.s
  silly_pattern <- "\\.\\."
  taxon <- gsub(pattern=silly_pattern, replacement="\\.", x=taxon)
  genus <- gsub(pattern=silly_pattern, replacement="\\.", x=genus)
  species <- gsub(pattern=silly_pattern, replacement="\\.", x=species)
  strain <- gsub(pattern=silly_pattern, replacement="\\.", x=strain)

  species_strain <- glue::glue("{species}.{strain}")
  genus_species <- glue::glue("{genus}.{species}")

  species_strain <- paste(unlist(strsplit(taxon, split="\\."))[-1], collapse=".")
  genus_species <- glue::glue("{genus}.{species}")

  gspecies <- glue::glue("{first}{species}")
  gsstrain <- glue::glue("{gspecies}{strain}")

  taxa <- list(
    "taxon" = taxon,
    "genus" = genus,
    "species" = species,
    "strain" = strain,
    "species_strain" = species_strain,
    "genus_species" = genus_species,
    "gspecies" = gspecies,
    "gsstrain" = gsstrain)
  return(taxa)
}

#' Create a data frame of pathways to gene IDs from KEGGREST
#'
#' This seeks to take the peculiar format from KEGGREST for pathway<->genes and
#' make it easier to deal with.
#'
#' @param species  String to use to query KEGG abbreviation.
#' @param abbreviation  If you already know the abbreviation, use it.
#' @param flatten  Flatten nested tables?
#' @return  dataframe with rows of KEGG gene IDs and columns of NCBI gene IDs
#'   and KEGG paths.
#' @author atb
#' @export
load_kegg_annotations <- function(species="coli", abbreviation=NULL, flatten=TRUE) {
  chosen <- NULL
  if (!is.null(abbreviation)) {
    species <- NULL
  }
  if (is.null(abbreviation) & is.null(species)) {
    stop("This requires either a species or 3 letter kegg id.")
  } else if (!is.null(abbreviation)) {
    chosen <- abbreviation
  } else {
    ## Then the species was provided.
    abbreviation <- get_kegg_orgn(species)
    if (length(abbreviation) == 0) {
      stop("Unable to find a matching abbreviation for the search: ", species, ".")
    }
    message("The possible abbreviations are: ", toString(abbreviation), ".")
    message("Choosing the first one: ", abbreviation[[1]])
    chosen <- abbreviation[[1]]
  }

  ## Getting a list of genes is easy, as they are unique.
  genes_vector <- try(KEGGREST::keggConv("ncbi-geneid", chosen))
  if (class(genes_vector) == "try-error") {
    if (grepl(pattern="HTTP 400", x=genes_vector)) {
      warning("KEGGREST returned bad request.")
      return(data.frame())
    }
  }
  genes_df <- kegg_vector_to_df(genes_vector, final_colname="ncbi_geneid", flatten=flatten)

  prot_vector <- KEGGREST::keggConv("ncbi-proteinid", chosen)
  prot_df <- kegg_vector_to_df(prot_vector, final_colname="ncbi_proteinid", flatten=flatten)

  uniprot_vector <- KEGGREST::keggConv("uniprot", chosen)
  uniprot_df <- kegg_vector_to_df(uniprot_vector, final_colname="uniprotid", flatten=flatten)

  path_vector <- KEGGREST::keggLink("pathway", chosen)
  path_df <- kegg_vector_to_df(path_vector, final_colname="pathways", flatten=flatten)

  if (isTRUE(flatten)) {
    result <- merge(genes_df, prot_df, by="GID", all=TRUE)
    rownames(result) <- result[["ID"]]
    result <- merge(result, uniprot_df, by="GID", all=TRUE)
    rownames(result) <- result[["ID"]]
    result <- merge(result, path_df, by="GID", all=TRUE)
    rownames(result) <- result[["ID"]]
  } else {
    result <- merge(genes_df, prot_df, by="GID", all=TRUE)
    result <- merge(result, uniprot_df, by="GID", all=TRUE)
    result <- merge(result, path_df, by="GID", all=TRUE)
  }

  result[["ncbi_geneid"]] <- gsub(
    pattern="ncbi-geneid:", replacement="", x=result[["ncbi_geneid"]])
  result[["ncbi_proteinid"]] <- gsub(
    pattern="ncbi-proteinid:", replacement="", x=result[["ncbi_proteinid"]])
  result[["uniprotid"]] <- gsub(pattern="up:", replacement="", x=result[["uniprotid"]])
  result[["pathways"]] <- gsub(pattern="path:", replacement="", x=result[["pathways"]])
  result[["kegg_geneid"]] <- glue::glue("{chosen}:{result[['GID']]}")
  ## Now we have a data frame of all genes <-> ncbi-ids, pathways
  result_nas <- is.na(result)
  result[result_nas] <- ""
  rownames(result) <- make.names(result[["GID"]], unique=TRUE)
  return(result)
}

#' Convert a potentially non-unique vector from kegg into a normalized data
#' frame.
#'
#' This function seeks to reformat data from KEGGREST into something which is
#' rather easier to use.
#'
#' This could probably benefit from a tidyr-ish revisitation.
#'
#' @param vector  Information from KEGGREST
#' @param final_colname  Column name for the new information
#' @param flatten Flatten nested data?
#' @return  A normalized data frame of gene IDs to whatever.
#' @author atb
kegg_vector_to_df <- function(vector, final_colname="first", flatten=TRUE) {
  final_df <- data.frame(stringsAsFactors=FALSE)
  if (isTRUE(flatten)) {
    sorted <- order(names(vector))
    sorted_vector <- vector[sorted]
    sorted_names <- names(sorted_vector)
    duplicated_names <- duplicated(sorted_names)
    unique_vector <- sorted_vector[!duplicated_names]
    unique_df <- as.data.frame(unique_vector, stringsAsFactors=FALSE)
    colnames(unique_df) <- final_colname
    ## Next line should not be needed with stringsAsFactors=FALSE
    ##unique_df[[final_colname]] <- as.character(unique_df[[final_colname]])
    duplicated_vector <- sorted_vector[duplicated_names]
    ## Now append the duplicated entries to the existing data frame.
    if (length(duplicated_vector) > 0) {
      for (c in 1:length(duplicated_vector)) {
        append_name <- names(duplicated_vector)[c]
        append_entry <- as.character(duplicated_vector[c])
        unique_df[append_name, final_colname] <- glue::glue(
          "{unique_df[append_name, final_colname]}, {append_entry}")
      }
    }
    final_df <- unique_df
    rm(unique_df)
    final_df[["GID"]] <- rownames(final_df)
    colnames(final_df) <- c(final_colname, "GID")
  } else {
    final_df <- as.data.frame(vector, stringsAsFactors=FALSE)
    final_df[["GID"]] <- names(vector)
    colnames(final_df) <- c(final_colname, "GID")
    na_set <- is.na(final_df)
    final_df[na_set] <- ""
  }
  final_df[["GID"]] <- gsub(pattern="^.*:", replacement="", x=final_df[["GID"]], perl=TRUE)
  return(final_df)
}

#' Load organism annotation data from an orgdb sqlite package.
#'
#' Creates a dataframe gene and transcript information for a given set of gene
#' ids using the AnnotationDbi interface.
#'
#' Tested in test_45ann_organdb.R
#' This defaults to a few fields which I have found most useful, but the brave
#' or pathological can pass it 'all'.
#'
#' @param orgdb OrganismDb instance.
#' @param gene_ids  Search for a specific set of genes?
#' @param include_go  Ask the Dbi for gene ontology information?
#' @param keytype mmm the key type used?
#' @param strand_column  There are a few fields I want to gather by default:
#'   start, end, strand, chromosome, type, and name; but these do not
#'   necessarily have consistent names, use this column for the chromosome
#'   strand.
#' @param start_column  Use this column for the gene start.
#' @param end_column  Use this column for the gene end.
#' @param chromosome_column  Use this column to identify the chromosome.
#' @param type_column  Use this column to identify the gene type.
#' @param name_column Use this column to identify the gene name.
#' @param fields Columns included in the output.
#' @param sum_exon_widths Perform a sum of the exons in the data set?
#' @return Table of geneids, chromosomes, descriptions, strands, types, and lengths.
#' @seealso \pkg{AnnotationDbi} \pkg{GenomicFeatures} \pkg{BiocGenerics}
#'  \code{\link[AnnotationDbi]{columns}} \code{\link[AnnotationDbi]{keytypes}}
#'  \code{\link[AnnotationDbi]{select}} \code{\link[GenomicFeatures]{exonsBy}}
#' @examples
#' \dontrun{
#'  one_gene <- load_orgdb_annotations(org, c("LmJF.01.0010"))
#' }
#' @author atb
#' @export
load_orgdb_annotations <- function(orgdb=NULL, gene_ids=NULL, include_go=FALSE,
                                   keytype="gid", strand_column="cdsstrand",
                                   start_column="cdsstart", end_column="cdsend",
                                   chromosome_column="cdschrom",
                                   type_column="gene_type", name_column="cdsname",
                                   fields=NULL, sum_exon_widths=FALSE) {
  if (is.null(orgdb)) {
    message("Assuming Homo.sapiens.")
    org_pkgstring <- "library(Homo.sapiens); orgdb <- Homo.sapiens"
    eval(parse(text=org_pkgstring))
  } else if ("character" %in% class(orgdb)) {
    org_pkgstring <- glue::glue("library({orgdb}); orgdb <- {orgdb}")
    eval(parse(text=org_pkgstring))
  }
  keytype <- toupper(keytype)
  strand_column <- toupper(strand_column)
  start_column <- toupper(start_column)
  end_column <- toupper(end_column)
  chromosome_column <- toupper(chromosome_column)
  type_column <- toupper(type_column)
  name_column <- toupper(name_column)
  ## Caveat: if fields was NULL, now it is character(0)
  fields <- toupper(fields)
  all_fields <- AnnotationDbi::columns(orgdb)
  chosen_fields <- c()

  if (! name_column %in% all_fields) {
    a_name <- grepl(pattern="NAME", x=all_fields)
    new_name_column <- all_fields[a_name][1]
    message("Unable to find ", name_column, ", setting it to ", new_name_column, ".")
    name_column <- new_name_column
  }
  if (! type_column %in% all_fields) {
    message("Unable to find ", type_column, " in the db, removing it.")
    type_column <- NULL
  }
  if (! chromosome_column %in% all_fields) {
    message("Unable to find ", chromosome_column, " in the db, removing it.")
    chromosome_column <- NULL
  }
  if (! strand_column %in% all_fields) {
    message("Unable to find ", strand_column, " in the db, removing it.")
    strand_column <- NULL
  }
  if (! start_column %in% all_fields) {
    message("Unable to find ", start_column, " in the db, removing it.")
    start_column <- NULL
  }
  if (! end_column %in% all_fields) {
    message("Unable to find ", end_column, " in the db, removing it.")
    end_column <- NULL
  }

  if (length(fields) == 0) {
    chosen_fields <- c(name_column, type_column, chromosome_column, strand_column,
                       start_column, end_column)
  } else {
    chosen_fields <- c(name_column, type_column, chromosome_column, strand_column,
                       start_column, end_column, fields)
  }

  if (sum(chosen_fields %in% all_fields) != length(chosen_fields)) {
    missing_idx <- ! chosen_fields %in% all_fields
    missing_fields <- chosen_fields[missing_idx]
    found_fields <- chosen_fields %in% all_fields
    chosen_fields <- chosen_fields[found_fields]
    message("Some requested columns are not available: ", toString(missing_fields), ".")
    message("The following are available: ", toString(all_fields))
  }

  if (chosen_fields[1] == "all") {
    message("Selecting the following fields, this might be too many: \n",
            toString(all_fields))
    chosen_fields <- all_fields
  }

  ## Gene IDs
  if (is.null(gene_ids)) {
    gene_ids <- try(AnnotationDbi::keys(orgdb, keytype=keytype))
    if (class(gene_ids) == "try-error") {
      if (grepl(x=gene_ids[[1]], pattern="Invalid keytype")) {
        valid_keytypes <- AnnotationDbi::keytypes(orgdb)
        stop("Try using valid keytypes: ", toString(valid_keytypes))
      } else {
        stop("There was an error getting the gene ids.")
      }
    } else {
      message("Extracted all gene ids.")
    }
  }
  ## Note querying by "GENEID" will exclude noncoding RNAs
  message("Attempting to select: ", toString(chosen_fields))
  gene_info <- try(AnnotationDbi::select(
                                    x=orgdb,
                                    keys=gene_ids,
                                    keytype=keytype,
                                    columns=chosen_fields))
  if (class(gene_info) == "try-error") {
    message("Select statement failed, this is commonly because there is no join",
            " between the transcript table and others.")
    message("Thus it says some stupid crap about 'please add gtc to the interpolator'",
            " which I think references select-method.R in GenomicFeatures.")
    message("So, try replacing columns with stuff like 'tx*' with 'cds*'?")
    stop()
  }

  ## Compute total transcript lengths (for all exons)
  ## https://www.biostars.org/p/83901/
  gene_exons <- try(GenomicFeatures::exonsBy(orgdb, by="gene"), silent=TRUE)
  if (class(gene_exons) == "try-error") {
    gene_exons <- NULL
  }
  transcripts <- try(GenomicFeatures::transcripts(orgdb), silent=TRUE)
  if (class(transcripts) == "try-error") {
    transcripts <- NULL
  }
  fivep_utr <- try(GenomicFeatures::fiveUTRsByTranscript(orgdb, use.names=TRUE), silent=TRUE)
  if (class(fivep_utr) == "try-error") {
    fivep_utr <- NULL
  }
  threep_utr <- try(GenomicFeatures::threeUTRsByTranscript(orgdb, use.names=TRUE), silent=TRUE)
  if (class(threep_utr) == "try-error") {
    threep_utr <- NULL
  }
  colnames(gene_info) <- tolower(colnames(gene_info))
  if (isTRUE(sum_exon_widths)) {
    message("Summing exon lengths, this takes a while.")
    lengths <- lapply(gene_exons, function(x) {
      sum(BiocGenerics::width(GenomicRanges::reduce(x)))
    })
    message("Adding exon lengths to the gene_exons.")
    lengths <- as.data.frame(unlist(lengths), stringsAsFactors=FALSE)
    colnames(lengths) <- "transcript_length"
    gene_info <- merge(gene_info, lengths, by.x=keytype, by.y="row.names")
  }
  rownames(gene_info) <- make.names(gene_info[[1]], unique=TRUE)

  retlist <- list(
    "genes" = gene_info,
    "gene_exons" = gene_exons,
    "transcripts" = transcripts,
    "fivep_utr" = fivep_utr,
    "threep_utr" = threep_utr)
  return(retlist)
}

#' Retrieve GO terms associated with a set of genes.
#'
#' AnnotationDbi provides a reasonably complete set of GO mappings between gene
#' ID and ontologies.  This will extract that table for a given set of gene
#' IDs.
#'
#' Tested in test_45ann_organdb.R
#' This is a nice way to extract GO data primarily because the Orgdb data sets
#' are extremely fast and flexible, thus by changing the keytype argument, one
#' may use a lot of different ID types and still score some useful ontology data.
#'
#' @param orgdb OrganismDb instance.
#' @param gene_ids Identifiers of the genes to retrieve annotations.
#' @param keytype  The mysterious keytype returns yet again to haunt my dreams.
#' @param columns  The set of columns to request.
#' @return Data frame of gene IDs, go terms, and names.
#' @seealso \pkg{AnnotationDbi} \pkg{GO.db} \pkg{magrittr}
#'  \code{\link[AnnotationDbi]{select}} \code{\link[dplyr]{tbl_df}}
#' @examples
#' \dontrun{
#'  go_terms <- load_go_terms(org, c("a","b"))
#' }
#' @author I think Keith provided the initial implementation of this, but atb
#'   messed with it pretty extensively.
#' @export
load_orgdb_go <- function(orgdb=NULL, gene_ids=NULL, keytype="ensembl",
                          columns=c("go", "goall", "goid")) {
  if (is.null(orgdb)) {
    message("Assuming Homo.sapiens.")
    org_pkgstring <- "library(Homo.sapiens); orgdb <- Homo.sapiens"
    eval(parse(text=org_pkgstring))
  } else if ("character" %in% class(orgdb)) {
    org_pkgstring <- glue::glue("library({orgdb}); orgdb <- {orgdb}")
    eval(parse(text=org_pkgstring))
  }
  tt <- requireNamespace("GO.db")
  keytype <- toupper(keytype)
  columns <- toupper(columns)
  if (is.null(gene_ids)) {
    gene_ids <- try(AnnotationDbi::keys(orgdb, keytype=keytype), silent=TRUE)
    if (class(gene_ids) == "try-error") {
      avail_types <- AnnotationDbi::keytypes(orgdb)
      if ("GID" %in% avail_types) {
        message("The chosen keytype was not available.  Using 'GID'.")
        keytype <- "GID"
        gene_ids <- AnnotationDbi::keys(orgdb, keytype=keytype)
      } else {
        keytype <- avail_types[[1]]
        message("Neither the chosen keytype, nor 'GID' was available.
The available keytypes are: ", toString(avail_types), "choosing ", keytype, ".")
        gene_ids <- AnnotationDbi::keys(orgdb, keytype=keytype)
      }
    }
  }
  if (class(orgdb)[[1]] == "OrganismDb") {
    message("This is an organismdbi, that should be ok.")
  } else if (class(orgdb)[[1]] == "OrgDb" | class(orgdb)[[1]] == "orgdb") {
    message("This is an orgdb, good.")
  } else {
    stop("This requires either an organismdbi or orgdb instance, not ", class(orgdb)[[1]])
  }
  available_columns <- AnnotationDbi::columns(orgdb)
  chosen_columns <- c()
  for (col in columns) {
    if (col %in% available_columns) {
      chosen_columns <- c(chosen_columns, col)
    }
  }
  if (is.null(chosen_columns)) {
    stop("Did not find any of: ", toString(columns),
         " in the set of available columns: ", toString(available_columns))
  }
  go_terms <- try(AnnotationDbi::select(x=orgdb,
                                        keys=gene_ids,
                                        keytype=keytype,
                                        columns=chosen_columns))
  if (class(go_terms) == "try-error") {
    if (grep(pattern="Invalid keytype", x=go_terms[[1]])) {
      message("Here are the possible keytypes:")
      message(toString(AnnotationDbi::keytypes(orgdb)))
      stop()
    }
  }
  ## Deduplicate
  go_terms <- go_terms[!duplicated(go_terms), ]
  if ("GO" %in% chosen_columns) {
    go_terms <- go_terms[!is.na(go_terms[["GO"]]), ]
    go_term_names <- AnnotationDbi::select(x=GO.db::GO.db,
                                           keys=unique(go_terms[["GO"]]),
                                           columns=c("TERM", "GOID", "ONTOLOGY"))
    go_terms <- merge(go_terms, go_term_names, by.x="GO", by.y="GOID")
  }

  ## Remove redundant annotations which differ only in source/evidence
  ## and rename ONTOLOGYALL column
  go_terms <- unique(dplyr::tbl_df(go_terms) %>% na.omit())
  return(go_terms)
}

#' Get an orgdb from an AnnotationHub taxonID.
#'
#' Ideally, annotationhub will one day provide a one-stop shopping source for a
#' tremendous wealth of curated annotation databases, sort of like a
#' non-obnoxious biomart.  But for the moment, this function is more
#' fragile than I would like.
#'
#' @param ahid  TaxonID from AnnotationHub
#' @param title  Title for the annotation hub instance
#' @param species  Species to download
#' @param type  Datatype to download
#' @return An Orgdb instance
#' @seealso \pkg{AnnotationHub} \pkg{S4Vectors}
#' @examples
#' \dontrun{
#'  orgdbi <- mytaxIdToOrgDb(taxid)
#' }
#' @author atb
#' @export
orgdb_from_ah <- function(ahid=NULL, title=NULL, species=NULL, type="OrgDb") {
  ## Other available types:
  tt <- loadNamespace("AnnotationHub")
  ah <- AnnotationHub::AnnotationHub()
  message("Available types: \n", toString(levels(as.factor(ah$rdataclass))))

  if (!is.null(type)) {
    ah <- AnnotationHub::query(x=ah, pattern=type)
  }
  if (is.null(title) & is.null(species) & is.null(ahid)) {
    message("Going to attempt to find a human database.  I hope this is what you want!")
    hits <- grepl(pattern="Hs\\.eg\\.db", x=ah$title)
    ahid <- names(ah)[hits]
  } else if (is.null(ahid) & is.null(title) & is.null(organism)) {
    ## Then we got a species
    possible <- ah$species
    titles <- ah$title
    hits_idx <- grepl(pattern=species, x=possible)
    first_true <- which.max(hits_idx)
    first_true_name <- titles[first_true]
    hits <- names(ah)[hits_idx]
    message("The possible hits are: \n",
            toString(hits), "\nchoosing: ", hits[1],
            "\nwhich is ", first_true_name)
    ahid <- hits[1]
  } else if (is.null(ahid) & is.null(species)) {
    ## We got a title
    possible <- ah$title
    hits_idx <- grepl(pattern=title, x=possible)
    first_true <- which.max(hits_idx)
    first_true_name <- possible[first_true]
    hits <- names(ah)[hits_idx]
    message("The possible hits are: \n",
            toString(hits), "\nchoosing: ", hits[1],
            "\nwhich is ", first_true_name)
    ahid <- hits[1]
  }

  ah_names <- names(ah)
  ah_titles <- ah$title
  hit_idx <- ah_names == ahid
  hit_num <- which.max(hit_idx)
  hit_title <- ah_titles[hit_num]
  message("Chose ", ahid, " which is ", hit_title, ".")
  res <- ah[[ahid]]
  return(res)
}

#' R CMD check is super annoying about :::.
#'
#' In a fit of pique, I did a google search to see if anyone else has been
#' annoyed in the same was as I.  I was in no way surprised to see that Yihui
#' Xie was, and in his email to r-devel in 2013 he proposed a game of
#' hide-and-seek; a game which I am repeating here.
#'
#' This just implements ::: as an infix operator that will not trip check.
#'
#' @param pkg on the left hand side
#' @param fun on the right hand side
`%:::%` <- function(pkg, fun) {
  get(fun, envir = asNamespace(pkg), inherits = FALSE)
}

getMaintainer <- "GenomicFeatures" %:::% ".getMaintainer"
getMetaDataValue <- "GenomicFeatures" %:::% ".getMetaDataValue"
getTxDbVersion <- "GenomicFeatures" %:::% ".getTxDbVersion"
normAuthor <- "GenomicFeatures" %:::% ".normAuthor"

## EOF
