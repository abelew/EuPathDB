---
title: "Accessing EuPathDB Resources using AnnotationHub"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing EuPathDB Resources using AnnotationHub}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteKeyword{eupathdb, annotations}
  \usepackage[utf8]{inputenc}
---

```{r style, echo=FALSE, results='asis', message=FALSE}
BiocStyle::markdown()
```

**Authors**: [V. Keith Hughitt](mailto:keith.hughitt@nih.gov)<br />
**Modified:** `r file.info("EuPathDB.Rmd")$mtime`<br />
**Compiled**: `r date()`

# Overview

This tutorial describes how to query and make use of annotations retrieved from
[EuPathDB : The Eukaryotic Pathogen Genomics Resource](http://eupathdb.org/eupathdb/)
using [AnnotationHub](http://bioconductor.org/packages/release/bioc/html/AnnotationHub.html).

For more information on using AnnotationHub, check out the AnnotationHub vignettes:

- [AnnotationHub: Access the AnnotationHub Web Service](http://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html)
- [AnnotationHub How-Toâ€™s](http://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html)

The resources described in this tutorial were generating using GFF files and web API requests made
to the various EuPathDB databases (TriTrypDB, ToxoDB, etc.) Only organisms with annotated genomes
(those for which GFF files are available) are accessible through AnnotationHub.

The two main resources provided are:

- [OrgDb](https://www.bioconductor.org/help/workflows/annotation/annotation/#OrgDb)
- [GRanges](http://bioconductor.org/packages/release/bioc/html/GenomicRanges.html)

OrgDb objects for an organism include basic gene-level information such as:

- Gene ID
- Gene description
- Chromosome number
- GO terms associated with gene
- KEGG Pathways associated with gene
- Etc.

For some organisms, [InterPro](https://www.ebi.ac.uk/interpro/) protein domain information is also
available (in some cases, however, even though InterPro domain information is available through
EuPathDB, it is too large to be included in the current AnnotationHub resources).

For more information about working with Bioconductor annotation resources, see:

- [Genomic Annotation Resources in Bioconductor ](https://www.bioconductor.org/help/workflows/annotation/annotation/)

# Installation

If you don't already have AnnotationHub installed on your system, use
`BiocManager::install` to install the package:

```{r install_pkgs, eval=FALSE}
install.packages("BiocManager")
BiocManager::install("AnnotationHub")
```

# Getting started

To begin, let's create a new `AnnotationHub` connection and use it to query
AnnotationHub for all EuPathDB resources.

```{r load_ah}
library("EuPathDB")
library("AnnotationHub")

# create an AnnotationHub connection
ah <- AnnotationHub()

# search for all EuPathDB resources
meta <- query(ah, "EuPathDB")

length(meta)
head(meta)

# types of EuPathDB data available
table(meta$rdataclass)

# distribution of resources by specific databases
table(meta$dataprovider)

# list of organisms for which resources are available
length(unique(meta$species))
head(unique(meta$species))
```

# Working with EuPathDB OrgDb resources

Next, we will see how you can query AnnotationHub for EuPathDB OrgDb resources.

To begin, create an AnnotationHub connection, if you have not already done so, as shown in the
section above.

You can now use the `query` function to search for your organism of interest and store the result
as follows:

```{r query_major}
res <- query(ah, c('Leishmania major strain Friedlin', 'OrgDb', 'EuPathDB'))
res
```

The result includes a single record, "AH56967". The record can be accessed from the result variable
using list-like indexing:

```{r get_major}
orgdb_uid <- names(res@.db_uid)
orgdb <- res[[orgdb_uid]]
class(orgdb)
```

We can see that we now have an OrgDb instance, and as such, we can use the usual methods available
for working this OrgDb objects, including:

- `columns()`
- `keys()`
- `select()`

```{r query_major_columns}
# list available fields to retrieve
columns(orgdb)

# create a vector containing all gene ids for the organism
gids <- keys(orgdb, keytype='GID')
head(gids)

# retrieve the chromosome, description, and biotype for each gene
dat <- select(orgdb, keys=gids, keytype='GID', columns=c('CHR', 'TYPE', 'GENEDESCRIPTION'))

head(dat)

table(dat$TYPE)
table(dat$CHR)

# create a gene / GO term mapping
gene_go_mapping <- select(orgdb, keys=gids, keytype='GID',
                          columns=c('GO_ID', 'GO_TERM_NAME', 'ONTOLOGY'))
head(gene_go_mapping)

# retrieve KEGG, etc. pathway annotations
gene_pathway_mapping <- select(orgdb, keys=gids, keytype='GID',
                               columns=c('PATHWAY', 'PATHWAY_SOURCE'))
table(gene_pathway_mapping$PATHWAY_SOURCE)
head(gene_pathway_mapping)
```

# Working with EuPathDB GRanges resources

In addition to retrieving gene annotations, AnnotationHub can also be used to query GenomicRange
(GRange) objects containing information about gene and transcript structure.

```{r query_granges}
# query AnnotationHub
res <- query(ah, c('Leishmania major strain Friedlin', 'GRanges', 'EuPathDB'))
res

# retrieve a GRanges instance associated with the result record
gr <- res[['AH65354']]
summary(gr)
head(gr)
```

The resulting `GRanges` object can then be interacted with using the [standard GRanges
functions](https://bioconductor.org/packages/3.7/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.pdf),
including:

- seqnames
- strand
- width

```{r extract_granges}
# chromosome names
seqnames(gr)

# strand information
strand(gr)

# feature widths
head(width(gr))
```

Some information can be retrieve directly as object properties using the `$` operator:

```{r get_types}
# list of location types in the resource
table(gr$type)
table(gr@strand)
```

To subset the GRanges instance, you can use the standard `[` operator:

```{r chr4}
# get the first three ranges
gr[1:3]

# get all gene entries on chromosome 4
chr4_genes <- gr[gr$type == 'gene' & seqnames(gr) == 'LmjF.04']
summary(chr4_genes)
## Hey, checkit, there are 130 genes on chromosome 4.
```

# Installing a new species in your R session

When AnnotationHub and the EupathDB web resources get out of sync, one might want to install
and manipulate the newest version of the available Eupath data.  The following blocks demonstrate
how one might do those tasks.

## Getting a less popular TriTrypDB data set

In some of my work, it is interesting to compare genes from species like
Leishmania to Crithidia fasculata.  In order to get the newest version of that
data, we need to query the TriTrypDB web resource rather than EupathDB.

```{r example_install}
## Note that some but not all web services have moved to https...
## tri_meta <- download_eupath_metadata(webservice="tritrypdb")

sc_entry <- get_eupath_entry(species="cerevisiae", webservice="fungidb")
sc_name <- sc_entry[["Species"]]
sc_entry
```

### Creating the package

Now that we have the canonical name from the TriTrypDB for Crithidia, we can
create a fresh orgdb package for it.  I will not actually run this because it
takes a long time and prints a lot to screen.

```{r pkg, eval=FALSE}
orgdb_pkg <- make_eupath_orgdb(sc_entry, reinstall=TRUE)
txdb_pkg <- make_eupath_txdb(sc_entry)
bsgenome_pkg <- make_eupath_bsgenome(sc_entry)
organ_pkg <- make_eupath_organismdbi(sc_entry)
```

### Another example from the tritrypdb

```{r lmajor, eval=FALSE}
lm_entry <- get_eupath_entry(species="Friedlin", webservice="tritrypdb")
lm_orgdb <- make_eupath_orgdb(lm_entry, reinstall=TRUE)
```

## Extracting annotation data

The following demonstrates ways to extract data from the generated orgdb package.

### Choosing and loading a generated package

Because the eupathdb is constantly evolving, the get_eupath_pkgnames() function will use
the metadata generated in download_eupath_metadata() in order to provide a differently
names package for each eupathdb revision.

```{r extract}
orgdb_pkg <- get_eupath_pkgnames(sc_entry)
sc_orgdb <- orgdb_pkg$orgdb
## Here is the name of the current yeast package.
sc_orgdb
## Thus we see the v41 (as of late 2018), a number which presumably will continue increasing.
## We can set the version parameter to change this if we have a previous version installed.

## Now get the set of available columns from it:
library(sc_orgdb, character=TRUE)
avail_columns <- AnnotationDbi::columns(get0(sc_orgdb))
head(avail_columns)
## There are lots of columns!
length(avail_columns)
```

### Extracting data from a package

Once we have a package loaded, everything else is an application of the
AnnotationDbi interface.  Here are a few examples.

Later I will show a couple of shortcuts for these methods.

```{r extract_data}
## The columns which begin with strings like 'PATHWAY' or 'INTERPRO' are actually separate
## sql tables in the orgdb database, and as such will lead to a hugely redundant data table
## if we select them.
chosen_columns_idx <- grepl(x=avail_columns, pattern="^ANNOT")
chosen_columns <- avail_columns[chosen_columns_idx]

## Now we have a set of columns of interest, let us get a data table/data frame.
sc_annot <- load_orgdb_annotations(orgdb=sc_orgdb, keytype="gid", fields=chosen_columns)
## load_orgdb_annotations will fill out separate dataframes for each annotation type,
## genes, exons, transcripts, etc.  In this case, we only want the genes
## (The eupathdb does not provide much information for the others.)
sc_genes <- sc_annot[["genes"]]
dim(sc_genes)
head(sc_genes)
## Yay! We have data about S. cerevisiae!

chosen_columns_idx <- grepl(x=avail_columns, pattern="^GO")
chosen_columns <- avail_columns[chosen_columns_idx]
sc_go <- load_orgdb_go(sc_orgdb, columns=chosen_columns)
head(sc_go)
## Yay Gene ontology data for Crithidia!

chosen_columns_idx <- grepl(x=avail_columns, pattern="^INTERPRO")
chosen_columns <- avail_columns[chosen_columns_idx]
sc_interpro <- load_orgdb_go(sc_orgdb, columns=chosen_columns)
head(sc_interpro)
## Interpro data for Crithidia!

chosen_columns_idx <- grepl(x=avail_columns, pattern="^PATHWAY")
chosen_columns <- avail_columns[chosen_columns_idx]
sc_path <- load_orgdb_go(sc_orgdb, columns=chosen_columns)
head(sc_path)
## Pathway data for Crithidia!

## This does not work for the moment because of some oddities with
## the various tables at the eupathdb.  I have an email query with them
## regarding it.
##chosen_columns_idx <- grepl(x=avail_columns, pattern="^ORTHOLOG")
##chosen_columns <- avail_columns[chosen_columns_idx]
##chosen_columns <- c(chosen_columns, "ORGANISM")
##crit_ortho <- load_orgdb_go(sc_orgdb, columns=chosen_columns)
##head(crit_ortho)
## Orthologs!
```

### Shortcut methods

Remembering the keytype and package names and everything can be annoying.
The following attempts to make that easier.  In this instance, the only thing we
need to provide is a unique substring for the species of interest.  If the
substring is not unique, this should show the matches and choose the first.

```{r shortcuts}
## The function load_eupath_annotations() provides a shortcut to the above.
major_annot <- load_eupath_annotations(species="major")
dim(major_annot)
## This provides the same information as the results of the select up above.
```

### Shortcut orthologs

A task I find myself needing to do fairly often is to get the set of genes
orthologous to a given gene.  There are lots of methods to handle this question;
one of them includes the nice table provided by the eupathdb.  Let us query that.

```{r orthologs, eval=FALSE}
## A recent EuPathDB update makes it possible to use the 'OrthologsLite' table rather than
## Orthologs, which is much faster (by like 1000x), but I am quickly realizing much more
## limited in the information it returns, and only exists for a subset of the eupathdb
## projects.  As a result, I might just drop its usage and force the much slower queries
## to the more complete table...
major_entry <- get_eupath_entry(species="major", webservice="tritrypdb")
major_pkg <- get_eupath_pkgnames(major_entry)
major_orgdb <- major_pkg$orgdb
lm_ortho <- extract_eupath_orthologs(major_orgdb)
dim(lm_ortho)
head(lm_ortho)
summary(lm_ortho)
```

# Session Information

```{r}
sessionInfo()
```
